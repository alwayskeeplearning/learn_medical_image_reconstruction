# 步骤4.3: API: Three.js 向量/矩阵、着色器 Uniform 传参、体素坐标到病人坐标的变换约定

## 核心 API

这一步，我们将熟悉 Three.js 中用于处理三维数学计算的核心 API，以及如何将我们在 CPU (TypeScript) 端计算好的数据传递给 GPU (GLSL) 端的着色器。

### 1. Three.js 中的向量：`THREE.Vector3`

`Vector3` 是 Three.js 中表示三维向量（或点）的类。我们理论中提到的 `origin`, `xAxis`, `yAxis`, `normal` 等，在代码中都会是 `Vector3` 的实例。

- **创建向量**: `new THREE.Vector3(x, y, z);`
- **常用方法**:
  - `.set(x, y, z)`: 修改向量的分量。
  - `.copy(v)`: 将另一个向量 v 的值拷贝过来。
  - `.normalize()`: **归一化**向量，使其长度变为1。
  - `.dot(v)`: 计算与另一个向量 v 的**点积**。
  - `.crossVectors(a, b)`: 计算向量 a 和 b 的**叉积**。
  - `.applyMatrix4(m)`: 将一个4x4矩阵 `m` 应用于该向量（进行坐标变换）。

### 2. Three.js 中的矩阵：`THREE.Matrix4`

`Matrix4` 是 Three.js 中表示 4x4 变换矩阵的类。我们理论中的 `voxelToPatientMatrix` 和 `patientToPatientMatrix` 都将是它的实例。

- **创建矩阵**: `new THREE.Matrix4();` (创建一个4x4单位矩阵)
- **常用方法**:
  - `.set(n11, n12, ..., n44)`: 按**列主序**设置矩阵的16个元素。
  - `.invert()`: **求逆矩阵**。
  - `.multiply(m)`: 将当前矩阵与另一个矩阵 `m` 相乘。
  - `.makeTranslation(x, y, z)`: 创建一个平移矩阵。
  - `.makeRotationFromEuler(euler)`: 从欧拉角创建一个旋转矩阵。
  - `.makeScale(x, y, z)`: 创建一个缩放矩阵。
  - `.compose(position, quaternion, scale)`: 从位置、四元数（旋转）和缩放来组合成一个变换矩阵。

### 3. 将数据传入着色器：`uniforms`

`uniform` 变量是连接 CPU 和 GPU 的桥梁。在使用 `ShaderMaterial` 时，我们需要定义一个 `uniforms` 对象。

```typescript
const material = new ShaderMaterial({
  uniforms: {
    uWindowWidth: { value: 400.0 },
    uOrigin: { value: new Vector3(0, 0, 0) },
    uPatientToVoxelMatrix: { value: new Matrix4() },
    uTexture: { value: some3DTexture },
  },
  // ... shaders
});

// 更新 uniform (最佳实践)
material.uniforms.uOrigin.value.set(10, 20, 30);
```

### 4. 变换约定

1.  **在 TypeScript 中**:
    - 解析 DICOM，构建出 `voxelToPatientMatrix`。
    - 调用 `.invert()` 方法，得到 `patientToVoxelMatrix`。
    - 根据当前视图的 `normal`，调用 `getAxes` 函数计算出 `xAxis` 和 `yAxis`。
    - 将所有需要的数据，通过 `material.uniforms` 对象的 `.value` 属性，赋值。
2.  **在 GLSL 中**:
    - 定义好同名的 `uniform` 变量。
    - 按照理论流程进行计算，完成采样和颜色输出。

---

## 学员问题与导师解答

### 问题 1: 关于 `.set()` 方法的列主序 (Column-Major Order)

**学员问题**: `.set(n11, n12, ..., n44): 按列主序设置矩阵的16个元素。`这句没看懂 什么叫主序？

**导师解答**:
“列主序”是一种在内存中存储矩阵元素的顺序。与我们习惯的“行主序”（先存完第一行再存第二行）不同，**列主序**是先存完第一列，再存第二列。OpenGL, GLSL, 和 Three.js 都使用列主序。

例如，一个平移矩阵：

```
[ 1, 0, 0, tx ]
[ 0, 1, 0, ty ]
[ 0, 0, 1, tz ]
[ 0, 0, 0, 1  ]
```

使用 `.set()` 时，需要按列传入参数：
`matrix.set(1,0,0,0,  0,1,0,0,  0,0,1,0,  tx,ty,tz,1);`
这就是为什么我们通常不直接用 `.set()`，而是用 `.makeTranslation()` 等更直观的方法。

### 问题 2: Matrix4 的缩放、旋转、平移组合

**学员问题**: Matrix4有创建平移矩阵、创建旋转矩阵；咋没有创建缩放矩阵？...直接用makeTransform(position, quaternion, scale)不是比transformMatrix.compose什么的更好?

**导师解答**:

1.  **关于缩放**: 我之前的回答有误，`THREE.Matrix4` **确实有** `.makeScale(x, y, z)` 方法。
2.  **关于组合**: Three.js 中没有一个静态的 `makeTransform` 方法。推荐的方式是使用实例方法 `.compose(position, quaternion, scale)`。

    这样设计的核心原因是**性能优化与对象重用**。在每秒执行60次的渲染循环中，如果频繁 `new Matrix4()` 会产生大量内存垃圾，导致浏览器进行垃圾回收（GC），从而引发页面卡顿。

    Three.js 的最佳实践是：**在初始化时创建对象，在渲染循环中更新它。**

    ```typescript
    // 初始化时创建
    const transformMatrix = new Matrix4();

    // 渲染循环中更新，不产生新对象
    function update() {
      transformMatrix.compose(position, quaternion, scale);
    }
    ```

    `.compose()` 是一个实例方法，其设计目的就是鼓励开发者去**重用（Reuse）**这个实例，从而获得最佳性能。

### 问题 3: `.value.copy(xxx)` vs `.value = xxx`

**学员问题**: `material.uniforms.uXAxis.value.copy(xAxis);`这句也没看懂 之前不都是value=xxx吗 怎么变成copy了？

**导师解答**:
这涉及到 JavaScript 中**对象引用**的概念。对于 `uniforms` 中的对象类型（`Vector3`, `Matrix4`, `Color` 等），**始终使用 `.copy()`、`.set()` 等方法来修改其内部值，而不是用 `=` 来替换整个对象**。

- `...value = xAxis;`: 这是**引用赋值**。让 `value` 这个“指针”指向一个新的对象。这种指针的彻底更换，Three.js 引擎追踪起来效率不高，且可能产生内存垃圾。
- `...value.copy(xAxis);`: 这是**值拷贝**。`value` 指向的对象不变，只是将其内部的 `x, y, z` 分量更新为 `xAxis` 的值。

**好处**:

1.  **引用稳定**: `uniform` 的 `value` 指针永远不变。
2.  **高效更新**: Three.js 内部机制非常擅长检测对象内部值的变化，并高效地同步到 GPU。
3.  **避免内存垃圾**: 不会频繁创建和丢弃新对象。

这是保证 Three.js 程序健壮性和性能的一条重要最佳实践。
