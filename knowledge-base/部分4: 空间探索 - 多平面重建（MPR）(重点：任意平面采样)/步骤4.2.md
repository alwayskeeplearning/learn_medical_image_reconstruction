# 步骤4.2: 理论: 平面法向/切向、矩阵变换与坐标系统一

## 核心理论

上一步我们用 `Origin`, `xAxis`, `yAxis` 来定义一个平面。这非常直观，但在实际的交互和计算中，我们往往会使用一种更工程化、更强大的工具来描述和操作这个平面——**矩阵（Matrix）**。

同时，为了确保我们计算出的三维采样坐标能够准确地对应到 `Data3DTexture` 中的体素，我们必须建立一套清晰、统一的坐标系约定。

### 1. 用“法向量”和“矩阵”来描述平面朝向

除了用 `xAxis` 和 `yAxis`，描述平面朝向的另一种常用方法是使用**法向量（Normal Vector）**。法向量是一个与平面上所有向量都垂直的向量。

一旦我们确定了法向量，也就唯一确定了平面的“朝向”。在 MPR 的应用中，三个标准正交视图的法向量就非常清晰：

- **轴位 (Axial)**: 法向量通常沿着病人的头脚方向，可以记为 `(0, 0, 1)`。
- **冠状位 (Coronal)**: 法向量沿着病人的前后方向，可以记为 `(0, 1, 0)`。
- **矢状位 (Sagittal)**: 法向量沿着病人的左右方向，可以记为 `(1, 0, 0)`。

如何从一个法向量 `normal` 推导出我们需要的 `xAxis` 和 `yAxis` 呢？我们可以借助向量的**叉积（Cross Product）**运算，并引入一个**参考向量 `up`** 来固定平面的旋转。

- `xAxis = normalize(cross(up, normal))`
- `yAxis = normalize(cross(normal, xAxis))`

这样，我们就从一个法向量构建出了一组完整的正交基（`xAxis`, `yAxis`, `normal`）。这三个向量共同构成了一个**变换矩阵**，可以描述我们采样平面的完整姿态。

### 2. 坐标系的约定与统一

在我们的项目中，至少存在以下三个核心坐标系：

- **A. 体素坐标系 (Voxel Coordinate System)**:

  - **单位**: 体素（Voxel）
  - **范围**: `(0, 0, 0)` 到 `(width-1, height-1, depth-1)`。
  - **描述**: `Data3DTexture` 内部的坐标系。GLSL 中 `sampler3D` 接受的是归一化后的体素坐标（范围 0 到 1）。

- **B. 病人坐标系 (Patient Coordinate System / World Coordinate System)**:

  - **单位**: 毫米 (mm)
  - **描述**: 由 DICOM 元数据定义的物理世界坐标系。我们定义的采样平面 `Origin`, `xAxis`, `yAxis` 就存在于这个坐标系中。

- **C. 我们自定义的平面坐标系**:
  - **单位**: 任意，我们设计为从 `-0.5` 到 `0.5`
  - **描述**: `(u, v)` 坐标，用于在渲染的二维平面上定位像素。

### 3. 核心任务：建立坐标系之间的转换

MPR 的渲染过程，本质上就是从 `C` 坐标系出发，最终得到 `A` 坐标系下的采样坐标。

**`C -> B`**: 从**平面坐标**转换到**病人坐标**。
`PatientPosition = Origin + (u * xAxis * Width) + (v * yAxis * Height)`

**`B -> A`**: 从**病人坐标**转换到**体素坐标**。
这一步需要一个 `patientToVoxelMatrix` 4x4 变换矩阵。
`VoxelPosition = patientToVoxelMatrix * vec4(PatientPosition, 1.0)`

这个 `patientToVoxelMatrix` 是 `voxelToPatientMatrix` 的**逆矩阵**。而 `voxelToPatientMatrix` 可以直接从 DICOM 的几何信息中构建出来，它充当了连接物理世界（毫米）和数据世界（体素）的桥梁。

### 4. 统一的渲染流程

1.  **[VS]** 将 `uv` 坐标从 `(0,1)` 范围转换到 `(-0.5, 0.5)` 范围，作为 `varying` 变量 `vUv` 传递给片元着色器。
2.  **[FS]** 使用 `vUv` 和平面定义 `uniforms`，计算出**病人坐标系**下的三维位置 `patientPos`。
3.  **[FS]** 使用 `uPatientToVoxelMatrix`，将 `patientPos` 变换到**体素坐标系**，得到 `voxelPos`。
4.  **[FS]** 对 `voxelPos` 进行归一化（除以纹理维度），得到最终的采样坐标 `sampleCoord`。
5.  **[FS]** 使用 `texture(uTexture, sampleCoord)` 对三维纹理进行采样。
6.  **[FS]** 应用窗宽窗位（WW/WL）计算，得到最终的灰度颜色并输出。

这个流程统一了所有 MPR 视图的渲染逻辑。我们只需要在 CPU 端改变传入的 `uniform` 变量，就可以控制 GPU 渲染出任意我们想要的剖面。

---

## 学员问题与导师解答

### 问题 1: 关于参考向量 `up` 的选择和 `patientToVoxelMatrix` 的构建

**学员问题 1.1**: `首先，我们需要一个“参考向量”，通常是场景中的“上方向”，比如 up = (0, 1, 0)。......这里我就懵了 为啥要选择(0, 1, 0) 那如果我选择(0, 0.5, 0) 那构建出的结果是完全不一样的啊？`

**导师解答**:
这个困惑非常有道理。答案是：**只要选择的参考向量不与法向量平行，经过归一化(normalize)处理后，最终构建出的 `xAxis` 和 `yAxis` 就是完全一样的。**

我们选择 `up` 向量时，**只关心它的方向，不关心它的长度**。`normalize()` 操作会消除掉原始向量长度的影响，只保留其方向。选择 `(0, 1, 0)` 只是一个方便的、符合三维坐标系直觉的惯例。真正的“禁区”是 `up` 向量不能和 `normal` 向量平行，因为两个平行向量的叉积是零向量，无法归一化。

**学员问题 1.2**: `这个 patientToVoxelMatrix 是如何构建的呢？...所以这个过程应该是先使用Pixel Spacing、Slice Thickness以及Image Orientation (Patient)构建旋转缩放矩阵然后再根据image Position (Patient)构建完整的变换矩阵voxelToPatientMatrix（旋转缩放平移）然后再对这个完整的变换矩阵求逆矩阵得到patientToVoxelMatrix？`

**导师解答**:
您的理解完全正确，堪称教科书般的总结！这正是构建这个关键矩阵的标准方法：

1.  **构建旋转缩放部分**：由 `Image Orientation (Patient)` (方向) 和 `Pixel Spacing` / `Slice Thickness` (尺度) 组合而成。
2.  **构建平移部分**：由 `Image Position (Patient)` (位置) 提供。
3.  **组合与求逆**：将以上部分组合成 4x4 的 `voxelToPatientMatrix`，然后求其逆矩阵，得到 `patientToVoxelMatrix`。

### 问题 2: 深入探讨 `up` 向量的意义与选择

**学员问题 2.1**: `我还是没懂 怎么靠一个法向量就可以确定一个坐标系...如果我选择了0.5,0.5,0呢 这个算出来的xAxis和yAxis不是发生了旋转？`

**导师解答**:
您的直觉是对的，我之前的解释为了简化而不够严谨。**您是对的，如果选择 `up = (0.5, 0.5, 0)`，算出来的 `xAxis` 和 `yAxis` 会发生旋转。**

一个法向量 `normal` 只能确定一个平面，但这个平面可以像风车一样绕着法向量旋转。正是为了解决这个“风车问题”，我们才引入了第二个向量 `up`。

更准确的结论是：**对于一个给定的法向量，我们必须约定一个固定的、可预见的 `up` 参考向量，来“卡住”风车，让它不再旋转，固定在一个我们期望的标准姿态上。** 在实际工程中，我们追求的是**可预测性和一致性**。因此我们**约定**选择一个与世界坐标系对齐的向量作为 `up`，最常用的就是 `(0, 1, 0)`。

**学员问题 2.2**: `你说不能平行 那我的代码怎么写 判断吗？如果不是0,1,0那我就用0,1,0 否则就是用0,0,1？类似这种？`

**导师解答**:
完全正确。在代码中，我们必须有一个健壮的判断逻辑。最常用、最高效的方法是使用**点积（Dot Product）**来判断两个单位向量是否平行。

伪代码如下：

```javascript
function getAxes(normal) {
  // 1. 定义我们首选的、常规的“上方向”
  let up = new Vector3(0, 1, 0);

  // 2. 判断 normal 和 up 是否过于接近平行（点积的绝对值接近1）
  if (Math.abs(normal.dot(up)) > 0.999) {
    // 如果平行，我们就换一个肯定不平行的参考向量
    up = new Vector3(1, 0, 0);
  }

  // 3. 现在可以安全地计算了
  const xAxis = new Vector3().crossVectors(up, normal).normalize();
  const yAxis = new Vector3().crossVectors(normal, xAxis).normalize();

  return { xAxis, yAxis };
}
```

**学员问题 2.3**: `我为什么不能选择0.5,0.5,0呢？如果我就是要重建斜切mpr呢？`

**导师解答**:
这是最关键的认知突破点：**我们不是通过改变 `up` 向量来实现斜切（Oblique）MPR 的。我们是通过改变 `normal` 向量来实现的。**

`normal` 和 `up` 的职责是彻底分开的：

- **`normal` (法向量)**: 决定了**你要切哪个平面**（视图的“角度”）。

  - 轴位: `(0,0,1)`
  - 矢状位: `(1,0,0)`
  - 斜切位: `normalize(1, 1, 0)` (或其他任意方向)

- **`up` (参考向量)**: 决定了**切出来的平面如何摆放**（视图的“摆放姿态”），防止它“打转”。

**最终比喻**：想象你是一个摄影师。

- **`normal`** 是你**相机镜头对准的方向**（正面、侧面、斜上方）。
- **`up`** 是你**相机的“水平仪”**，确保照片总是“正”的，头在上方。

我们通过改变 `normal` 来实现任意角度的斜切，同时使用一个固定的、有判断逻辑的 `up` 来保证这些视图都以一种标准的、不旋转的姿态呈现给用户。
