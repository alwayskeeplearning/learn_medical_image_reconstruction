# 知识库：步骤 4.4.0 - 实践：正交三视图布局（单渲染器多视口）

## 1. 核心目标

实现医学影像工作站中最经典的**多视口（Multi-Viewport）布局**。不再是在一个 3D 空间中看交叉平面，而是让轴位、冠状位、矢状位各自占据独立的屏幕区域。

---

## 2. 技术架构：单渲染器多视口方案

为了保持高性能，我们避免创建多个 WebGL 上下文，而是通过一个渲染器管理多个视图区域。

### 2.1 渲染管线控制

在每一帧渲染循环中，执行以下操作：

1. **视口映射 (`setViewport`)**: 指定当前视图在 Canvas 上的矩形区域。
2. **裁剪测试 (`setScissor`)**: 限制绘制范围。这是最关键的一步，它能防止 `renderer.clear()` 时把其他已经画好的视口内容擦掉。
3. **渲染顺序**:
   ```typescript
   renderer.setScissorTest(true);
   views.forEach(view => {
     const rect = view.element.getBoundingClientRect();
     renderer.setViewport(rect.left, bottom, width, height);
     renderer.setScissor(rect.left, bottom, width, height);
     renderer.render(view.scene, view.camera);
   });
   renderer.setScissorTest(false);
   ```

### 2.2 视图自适应算法

为了让影像在不同宽高比的 `div` 容器中都不变形，需要动态调整相机的视锥体：

- **逻辑**: 比较“容器宽高比”与“影像物理宽高比”。
- **结果**: 如果容器太宽，则以高度为基准固定，宽度两侧留白；反之则以宽度为基准，上下留白。

---

## 3. 几何修正：层间距 (Z-Spacing)

这是医学影像处理中极易被忽略的细节：

- **问题**: DICOM 标签中的 `SliceThickness`（层厚）描述的是切片本身的厚度，但不代表切片中心点之间的距离。如果只用层厚，重建出来的图像会被压扁或拉长。
- **解决方案**: 通过相邻切片的 `ImagePositionPatient` 标签计算欧式距离。
  $$zSpacing = \text{distance}(P_{slice0}, P_{slice1})$$
- **意义**: 这个值才是构建 3D 纹理和变换矩阵时，Z 轴方向最准确的物理间距。

---

## 4. 关键 API 与 交互逻辑

- **`getBoundingClientRect()`**: 用于实时获取 DOM 容器的位置，将 HTML 布局信息传递给 WebGL。
- **`ShaderMaterial` 克隆与同步**:
  - 为每个视图克隆独立的材质。
  - **同步项**: 窗宽窗位（WW/WL）、纹理对象（Shared Texture）。
  - **独立项**: `uOrigin`（切面位置）、`uXAxis`/`uYAxis`（切面方向）。

---

## 5. 实践验证

- **布局一致性**: 轴位居左，冠状位、矢状位居右堆叠，符合标准放射学布局。
- **比例准确性**: 改变浏览器窗口大小时，圆形解剖结构（如主动脉）应始终保持圆形，不发生拉伸。
- **独立控制**: 拖动轴位滑块时，只有轴位视图发生切换，不影响其他两个视图。

