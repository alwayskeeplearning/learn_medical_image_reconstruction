# 步骤1.3: 实践 - 使用 `dicom-parser` 加载、读取元数据与像素数据

## 实践目标

创建一个简单的网页，允许用户选择一个本地的 `.dcm` 文件。当文件被选中后，使用 `dicom-parser` 解析它，并在页面上显示出一些关键的元数据，同时在控制台打印出像素数据的基本信息。

## 核心实现思路

本次实践严格遵循了我们在步骤1.2中总结的5步工作流程：

1.  **加载文件**: 使用浏览器内置的 `FileReader` API 的 `readAsArrayBuffer` 方法来异步读取用户选择的文件，获取其原始二进制内容 (`ArrayBuffer`)。
2.  **转换格式**: `dicom-parser` 需要 `Uint8Array` 格式的输入，所以我们通过 `new Uint8Array(arrayBuffer)` 进行了一次简单的格式转换。
3.  **解析**: 调用 `dicomParser.parseDicom(byteArray)` 这个核心函数，它执行了复杂的解析工作，并返回一个结构化的 `dataSet` 对象。
4.  **读取元数据**: 利用 `dataSet` 对象提供的 `string()` 和 `uint16()` 等便捷方法，像查询字典一样，通过Tag ID（如 `'x00100010'`）来提取我们关心的元数据（如患者姓名、图像尺寸、像素格式等）。
5.  **定位像素数据**: 通过访问 `dataSet.elements.x7fe00010` 来获取像素数据元素，并读取其 `dataOffset` (偏移量) 和 `length` (字节长度) 属性，以确认我们能成功找到它。

整个过程还包含了健壮的 `try...catch` 错误处理机制，确保在解析失败时能向用户提供清晰的反馈。

---

## Q&A (问题与解答)

### Q: 我看到页面输出的 `Pixel Data` 的 `Length (bytes)` 是 524288，但我计算的 `512 * 512` 像素个数是 262144。这个长度为什么是像素数的两倍？

**A:** 这是一个非常敏锐的观察！这个问题直接关联到了我们之前讨论的 DICOM 核心理论。

答案就在您同时解析出的另一个元数据里：**`Bits Allocated`**。

在您的例子中，`Bits Allocated (0028,0100)` 的值是 **16**。

- **`Bits Allocated: 16`** 意味着，为了存储每个像素，系统都分配了 16 位的内存空间。
- 在计算机中，8 bits 等于 1 byte。
- 因此，16 bits 就等于 **2 bytes**。

所以，存储**一个**像素就需要 **2 个字节**。

基于这个信息，我们可以重新计算总的字节长度：

`512 (图像行数) * 512 (图像列数) * 2 (每个像素占用的字节数) = 262144 * 2 = 524288 字节`

这个计算结果与您在页面上看到的 `Length (bytes): 524288` 完全吻合。

这个实例生动地证明了 `Bits Allocated` 的重要性：它定义了每个像素在内存中的“大小”，是我们正确理解和操作像素数据流的基础。
