# 步骤1.2: `dicom-parser` 核心 API

## API 讲解

`dicom-parser` 是一个专门用 JavaScript 编写的库，可以让我们轻松地从 DICOM 文件中提取出需要的数据，比如患者姓名、图像尺寸，当然还有最重要的像素数据。

### 1. 如何安装？

通过 npm（或 pnpm/yarn）来安装:

```bash
pnpm install dicom-parser
```

### 2. 核心 API 概览

这个库的核心思想是：你给它一堆二进制数据（DICOM 文件的内容），它给你返回一个结构化的 JavaScript 对象，让你能方便地访问里面的信息。

- `dicomParser.parseDicom(byteArray, options)`:

  - **作用**: 这是最核心的函数，是所有魔法的起点。
  - **参数**:
    - `byteArray`: 这是一个 `Uint8Array` 类型的数组，代表了 DICOM 文件的原始二进制内容。
    - `options`: 一个可选的配置对象，现在我们可以暂时忽略它。
  - **返回值**: 它会返回一个 `dataSet` 对象。这个对象就是我们前面比喻的那个“字典”，里面装满了从 DICOM 文件里解析出来的各种数据元素。

- **The `dataSet` Object (数据集对象)**:

  - 这个对象是解析结果的集合，它有一系列非常有用的方法来获取数据。
  - `dataSet.string(tag)`: 获取指定 `tag` 对应的值，并将其作为**字符串**返回。
    - **示例**: `const patientName = dataSet.string('x00100010');`
    - **注意**: Tag 的格式是 `x` 加上 8 位的十六进制数。
  - `dataSet.uint16(tag)` / `dataSet.int16(tag)`: 获取指定 `tag` 的值，并将其作为 16 位的**无符号/有符号整数**返回。
    - **示例**: `const rows = dataSet.uint16('x00280010');`
  - `dataSet.float(tag)` / `dataSet.double(tag)`: 获取浮点数或双精度浮点数值。
    - **示例**: `const rescaleSlope = dataSet.double('x00281053');`
  - `dataSet.elements`: 这是一个对象，包含了所有解析出来的数据元素。其中，我们最关心的就是像素数据。
    - `dataSet.elements.x7fe00010`: 这就是指向**Pixel Data** 元素的“指针”。

- **处理 Pixel Data**

  - 通过 `dataSet.elements.x7fe00010` 拿到的像素数据元素，包含了一些重要信息：
    - `dataOffset`: 告诉我们像素数据在整个 `byteArray` 文件字节流中的起始位置（偏移量）。
    - `length`: 告诉我们像素数据的总字节长度。
  - 有了这两个信息，我们就可以从原始的 `byteArray` 中精确地“裁剪”出像素数据部分。

- **TypedArray (类型化数组)**
  - 从 DICOM 中取出的像素数据，其值的类型是由 `Bits Stored (0028,0101)` 和 `Pixel Representation (0028,0103)` 等 Tag 决定的。JavaScript 提供了 `TypedArray` 来高效处理二进制数据。
  - `Uint8Array`: 数组中每个元素都是 8 位无符号整数 (0-255)。
  - `Int16Array`: 数组中每个元素都是 16 位有符号整数 (-32768 到 32767)。
  - `Uint16Array`: 数组中每个元素都是 16 位无符号整数 (0-65535)。

### 总结工作流程

1.  **加载文件**: 把 `.dcm` 文件读成一个 `Uint8Array`。
2.  **解析**: 调用 `dicomParser.parseDicom()` 获得 `dataSet` 对象。
3.  **读取元数据**: 使用 `dataSet.string()`、`dataSet.uint16()` 等方法读取我们需要的各种信息。
4.  **定位像素数据**: 找到 `dataSet.elements.x7fe00010`，获取其 `dataOffset` 和 `length`。
5.  **创建像素数组**: 根据元数据判断像素类型，然后在原始 `byteArray` 的相应位置上创建一个正确类型的 `TypedArray`。

---

## Q&A (问题与解答)

### Q1: 对于 DICOM Tag 中包含多个值（如窗宽窗位、ImagePosition）的情况，应该如何读取？

**A:** 这是一个非常棒的问题。对于值表示(VR)是字符串类型的多值 Tag，`dicom-parser` 会返回一个由反斜杠 `\` 分隔的单个字符串。我们需要自己来解析这个字符串。

**处理步骤:**

1.  使用 `.string()` 方法获取原始字符串。
    ```javascript
    const imagePositionString = dataSet.string('x00200032');
    // -> "-170.0\-170.0\-78.0"
    ```
2.  使用 JavaScript 的 `split()` 方法按反斜杠 `\` 分割字符串。
    ```javascript
    const positionValues = imagePositionString.split('\\');
    // -> ["-170.0", "-170.0", "-78.0"]
    ```
3.  将字符串数组转换为数值数组。
    ```javascript
    const imagePosition = positionValues.map(value => parseFloat(value));
    // -> [-170.0, -170.0, -78.0]
    ```

**总结规律:**

| Tag 类型                    | 值表示(VR) | `dicom-parser` 返回值    | 我们的处理方式                                                                 |
| :-------------------------- | :--------- | :----------------------- | :----------------------------------------------------------------------------- |
| 单值数字 (如 Rows)          | `US`       | 数字 (Number)            | 直接使用 `dataSet.uint16()` 读取                                               |
| 多值数字 (如 ImagePosition) | `DS`       | 单个字符串 (用 `\` 分隔) | 使用 `dataSet.string()` 读取，然后 `.split('\\')` 分割，再用 `parseFloat` 转换 |
| 单值文本 (如 PatientName)   | `PN`       | 字符串 (String)          | 直接使用 `dataSet.string()` 读取                                               |

---

### Q2: Tag 的类型（字符串、整型、浮点型）是靠自己记住，还是有办法自描述？

**A:** DICOM 是**自描述的**。每个数据元素都明确存储了自己的 **VR (Value Representation)**，它定义了值的类型。`dicom-parser` 在解析时会自动读取 VR 并据此解释数据。我们之所以使用 `dataSet.string()` 或 `dataSet.uint16()` 这样的不同方法，是为了基于我们的**意图**方便地获取 JavaScript 中的原生类型。最佳实践是根据你想要的数据类型（数字或字符串）来选择对应的方法。

---

### Q3: `Bits Stored` 和 `Pixel Representation` 是如何共同决定像素数据类型的？

**A:** 这两个 Tag 组合在一起，完整地定义了像素值的数字类型。

- `Bits Stored (0028,0101)`: 决定了像素值的**位数**（8, 12, 16等）。
- `Pixel Representation (0028,0103)`: 决定了像素值是**有符号** (`1`)还是**无符号** (`0`)。

**常见组合示例:**

| `Bits Stored` | `Pixel Representation` | 实际含义                         | 常见影像类型         | 应该使用的 `TypedArray` |
| :------------ | :--------------------- | :------------------------------- | :------------------- | :---------------------- |
| 16            | 1                      | 16位有符号整数 (-32768 to 32767) | CT 图像 (HU值有负数) | `Int16Array`            |
| 8             | 0                      | 8位无符号整数 (0 to 255)         | 二次图像、某些超声   | `Uint8Array`            |
| 16            | 0                      | 16位无符号整数 (0 to 65535)      | 数字X光片(DR)、MRI   | `Uint16Array`           |

---

### Q4: 既然有了 `Bits Stored`，为什么还需要 `Bits Allocated`？我们应该用 `Bits Allocated` 和 `Pixel Representation` 的组合吗？

**A:** 这是个非常深入的问题！`Bits Allocated` 和 `Bits Stored` 各司其职，缺一不可。

- **`Bits Allocated (0028,0100)`** 像是 **“快递盒”** 的大小。它定义了为每个像素分配的**内存空间**（通常是8或16位，为了内存对齐）。这是给**解析器**看的，决定了我们应该用 `Int8Array` 还是 `Int16Array` 来**读取内存**。
- **`Bits Stored (0028,0101)`** 像是快递盒里 **“物品”** 的真实大小。它定义了在分配的空间中，有多少位是**真正有效的像素数据**（比如12位）。这是给**应用程序**看的，它决定了像素的**真实数值范围**。我们所有的后续计算（如窗宽窗位）都必须基于这个真实范围，否则结果会不准确。

**总结:**

| Tag                        | 角色         | 决定了什么？                             | 谁关心它？                          |
| :------------------------- | :----------- | :--------------------------------------- | :---------------------------------- |
| **`Bits Allocated`**       | **内存布局** | 如何从二进制流中正确地**读取**一个像素。 | **解析器** (创建 `TypedArray` 时)   |
| **`Bits Stored`**          | **数值范围** | 像素值的**有效**取值范围是什么。         | **应用程序** (进行窗宽窗位等计算时) |
| **`Pixel Representation`** | **符号**     | 值是**有符号**还是**无符号**的。         | **解析器** 和 **应用程序**          |

**完美流程:**

1.  用 `Bits Allocated` 和 `Pixel Representation` 组合，选择正确的 `TypedArray` 来**读取**像素数据。
2.  用 `Bits Stored` 来理解这些数据的**真实数值范围**，从而进行正确的显示和计算。
