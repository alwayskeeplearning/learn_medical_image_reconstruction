# 步骤1.7: 实践 - 交互拖拽实时调节 WW/WL

## 实践目标

在静态渲染的基础上，增加鼠标事件监听。当用户在Canvas图像上按下并拖动鼠标时，水平移动将改变**窗宽**，垂直移动将改变**窗位**，并且图像会**实时**根据新的窗宽窗位值进行重绘，完成医学影像查看器最核心的交互功能。

## 核心实现解读

为实现流畅的交互，我们引入了几个关键技术点：

1.  **状态管理**: 我们创建了全局变量来维护当前加载的图像信息(`currentDicomInfo`)、鼠标拖拽状态(`isDragging`)以及上一次的鼠标位置(`lastMousePosition`)。这使得数据可以在不同的事件监听器之间共享。

2.  **鼠标事件监听**: 我们为`<canvas>`元素绑定了三个核心的鼠标事件：

    - `mousedown`: 记录下鼠标拖拽的起始位置，并将`isDragging`状态设为`true`。
    - `mousemove`: 这是交互的核心。当`isDragging`为`true`时，计算当前鼠标位置与上一位置的差值`deltaX`和`deltaY`。然后用这两个差值去更新`currentDicomInfo`中的`windowWidth`和`windowCenter`。
    - `mouseup` / `mouseleave`: 将`isDragging`状态设为`false`，停止拖拽。

3.  **实时重绘与性能优化**:
    - 在`mousemove`事件中，每当窗宽窗位值更新后，我们都会**重新调用`renderImage`函数**来重绘整个图像。
    - 为了避免`mousemove`高频触发导致的性能问题，我们将重绘调用包裹在`requestAnimationFrame`中。这确保了即使鼠标移动得再快，我们的`renderImage`函数在每一帧也只会被执行一次，从而实现平滑、高效的渲染。

---

## Q&A (问题与解答)

### Q: 在高频的`mousemove`事件中频繁调用`requestAnimationFrame`，会不会有问题？期间的多次调用会合并还是丢失？

**A:** 这个问题触及了浏览器渲染性能的核心。简而言之，**这种用法完全正确，并且是性能最佳的实践**。`requestAnimationFrame`(rAF)的设计正是为了优雅地处理这个问题。

`rAF`**不是定时器**，它是一个**“请求/预约”系统**。在同一帧内对同一个回调函数的多次调用，实际上只会有一次预约成功。

**工作机制推演:**

1.  **数据更新与渲染预约是分离的**:

    - `mousemove`事件触发时，我们的代码会**立即更新**数据（如`currentDicomInfo.windowWidth`）。
    - 然后，它向浏览器**预约**在下一帧执行`render`函数。

2.  **预约合并**:

    - 在同一帧的时间内（约16.7ms），`mousemove`可能触发了10次。
    - 第一次触发时，成功预约了一次`render`。
    - 后9次触发时，浏览器发现`render`函数已经被预约了，就会**忽略**这些重复的预约请求。
    - 与此同时，`currentDicomInfo`的值被连续更新了10次。

3.  **最终执行**:
    - 当下一帧到来时，浏览器执行那**唯一一次**被成功预约的`render`函数。
    - `render`函数会读取`currentDicomInfo`的**最新值**来进行绘制。

**结论**: `mousemove`中高频触发`rAF`，最终效果是**数据被实时更新，而渲染任务被智能地合并到每帧一次**。这种“省略后面排进来的任务”的机制，完美地保证了渲染与屏幕刷新率同步，避免了资源浪费，实现了流畅的交互。
