# 步骤1.5: API - Canvas2D 与 `ImageData`

## API 讲解

理论知识储备完毕后，我们需要一个舞台来展示它——HTML5 的 `<canvas>` 元素。通过它，我们可以在CPU层面直接操作像素，并将它们“画”到屏幕上。

### 1. `<canvas>` 元素与 2D 上下文

`<canvas>` 是一个HTML元素，它本身是一块空白画板，必须使用JavaScript来绘制。我们通过 `getContext('2d')` 来获取它的2D绘图上下文，这个上下文对象就是我们的“画笔”。

```javascript
const canvas = document.getElementById('my-canvas') as HTMLCanvasElement;
const ctx = canvas.getContext('2d');
```

### 2. `ImageData` 对象：像素的容器

`ImageData` 是一个JavaScript对象，代表了 `<canvas>` 区域一块矩形范围内的底层像素数据。它是像素值的“容器”。

- **创建**: `ctx.createImageData(width, height)` 创建一个指定大小的、空白的`ImageData`对象。
- **结构**:
  - `width`: 图像数据的宽度（像素）。
  - `height`: 图像数据的高度（像素）。
  - `data`: 一个 `Uint8ClampedArray` 类型的数组，是`ImageData`的核心。

### 3. `data` 数组与 RGBA 排列

`Uint8ClampedArray` 是一个特殊的`TypedArray`，其元素都是`0-255`之间的整数，超出范围的值会被“钳住”，非常适合表示颜色通道。

这个`data`数组是一个一维数组，但它以**RGBA**的顺序来描述二维图像：

- 数组中的**每4个连续的元素**，共同定义了**一个**像素的颜色。
  - 第1个元素: **R** - 红色通道 (0-255)
  - 第2个元素: **G** - 绿色通道 (0-255)
  - 第3个元素: **B** - 蓝色通道 (0-255)
  - 第4个元素: **A** - 透明度通道 (0-255, 0是完全透明, 255是完全不透明)

### 4. 将 `ImageData` 绘制到 Canvas

当我们用JS循环，将处理后的像素灰度值填入`ImageData.data`数组后，就可以用 `putImageData` 方法把它一次性“刷”到画板上，这个操作经过浏览器底层优化，速度很快。

`ctx.putImageData(imageData, dx, dy);`

- `imageData`: 填充好数据的`ImageData`对象。
- `dx`, `dy`: 在`<canvas>`画板上绘制的起始坐标点（通常是 `0, 0`）。

---

## Q&A (问题与解答)

### Q1: 对于灰度图，为什么需要让R, G, B三个通道都等于同一个灰度值？只设置R通道不行吗？

**A:** 这个问题的关键在于 `ImageData` 这个API天生是为**彩色图像**设计的，其 `[R, G, B, A]` 的数据结构是固定的。浏览器渲染时会严格按照这个结构分别驱动屏幕上红、绿、蓝三个子像素点。

- **如果只设置R通道** (例如 `[150, 0, 0, 255]`)，浏览器会解读为只有红色子像素发光，最终在屏幕上看到的会是一个**纯粹的红色像素**，整张图会变成一张红色调图。
- **正确的做法**是让R, G, B三个通道的值完全相等 (例如 `[150, 150, 150, 255]`)。当红、绿、蓝三个子像素以**完全相同的强度**发光时，根据人眼视觉原理，它们混合成的颜色就是**灰色**。

**结论**: 为了在为彩色设计的RGBA系统中正确显示灰度，我们必须通过确保R、G、B三个颜色通道的值完全相等来**模拟**出灰色的效果。

### Q2: 那可以使用Alpha通道吗？就是不设置RGB，只设置A（透明度）呢？

**A:** 这是个非常有创意的想法，让我们推演一下。如果设置像素为 `[R=0, G=0, B=0, A=150]`，浏览器会如何解读？

1.  **颜色 (RGB)**: `R=0, G=0, B=0` 代表**纯黑色**。
2.  **透明度 (Alpha)**: `A=150` 代表这个像素是**半透明**的。

最终效果是得到一个**半透明的黑色像素**。整张图会变成一张带有不同透明度的黑色图像。虽然在白色背景下，它看起来有点像灰度图（透明度低的黑色会透出更多白色背景，显得更“亮”），但这是一种“假”的灰度图。如果`canvas`的背景色变为红色，图像就会呈现为各种深浅不同的暗红色。

**结论**: Alpha通道被设计用来控制像素的**透明度(transparency)**，而不是它的**亮度(luminance/intensity)**。为了得到一张真正的、不受背景影响的灰度图，我们必须通过设置**相等的 R, G, B 值**来控制亮度。
