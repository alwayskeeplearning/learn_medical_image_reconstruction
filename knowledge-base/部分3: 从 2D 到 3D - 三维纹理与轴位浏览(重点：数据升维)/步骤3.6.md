### 步骤3.6: (实践) 修改着色器以采样 3D 纹理，使用 `slice` 索引渲染指定切片

在这一步，我们成功地将上一环节在 GPU 中创建的 `Data3DTexture` 渲染到了屏幕上，并解决了在此过程中遇到的一系列关键问题。这是我们课程的一个重要里程碑。

---

#### 1. 核心任务：从三维纹理中渲染一个二维切片

我们的目标是编写一套全新的 GLSL 着色器，它可以从一个三维数据体中，根据我们从 CPU 传入的切片索引，精确地采样并显示出任意一个二维平面。

---

#### 2. GLSL 3.0 着色器：为三维采样而生

为了使用三维纹理，我们必须启用 WebGL2/GLSL 3.0 的功能，这要求我们对著色器代码进行“升维”：

- **GLSL 版本声明**: 着色器代码**必须**由 Three.js 的材质 `glslVersion: THREE.GLSL3` 选项来声明版本，而不是在代码中手动写入 `#version 300 es`。
- **关键字更新**:
  - `varying` -> `out` (在顶点着色器) / `in` (在片元着色器)。
  - `gl_FragColor` -> 自定义 `out vec4 outColor;`。
- **三维采样**:
  - **采样器类型**: 使用 `uniform sampler3D u_volumeTexture;` 替代 `sampler2D`。
  - **采样函数**: 使用统一的 `texture()` 函数替代 `texture2D()`。
  - **三维纹理坐标**: `texture()` 函数需要一个 `vec3` 坐标。我们将平面的二维 `vUv` 和一个代表深度的 `uniform float u_slice` 组合成 `vec3(vUv, u_slice)` 来进行采样。

---

#### 3. 关键实践问题与解决方案

在实践中，我们遇到并解决了一系列非常典型且有价值的问题：

##### a. `ShaderMaterial` vs `RawShaderMaterial`

- **遇到的问题**: 我们最初使用 `ShaderMaterial` 时，遇到了两个致命的着色器编译错误：`#version` 重复定义 和 `position` 等变量重复定义。
- **原因剖析**: `ShaderMaterial` 为了方便开发者，会在我们写的 GLSL 代码**前面**自动“注入”一段它自己的通用代码块（包含 `projectionMatrix`, `position` 等变量声明）。当我们设置 `glslVersion: THREE.GLSL3` 时，它还会自动注入 `#version 300 es`。这种“自动注入”的行为，与我们自己写的、完整的 GLSL 3.0 代码产生了严重冲突。
- **解决方案**: 切换到 `THREE.RawShaderMaterial`。这是一个“专业模式”的材质，它**完全不会**注入任何代码，给予了我们对 GLSL 的 100% 控制权。切换后，我们需要在顶点着色器中**手动声明**所有需要用到的内置变量，如 `uniform mat4 projectionMatrix;` 和 `in vec3 position;` 等。
- **结论**: 当你需要使用 WebGL2/GLSL 3.0 的高级功能，并且想要对著色器有完全的、无干扰的控制时，`RawShaderMaterial` 是最干净、最可靠的选择。

##### b. 图像变形 (Resize 问题)

- **遇到的问题**: 渲染出的图像被不成比例地拉伸或压缩了。
- **原因剖析**: 我们渲染的画布（浏览器窗口）的宽高比，与我们 DICOM 图像本身的宽高比不一致。
- **解决方案**: 编写一个 `onWindowResize` 函数。核心逻辑是：在窗口大小改变时，动态地调整正交相机 `OrthographicCamera` 的视野范围（`left`, `right`, `top`, `bottom`），使其视野的宽高比始终与窗口的宽高比保持一致。这样就能确保图像以正确的比例被“框”在窗口中，多余的部分则留出黑边。

##### c. 图像翻转 (Y 轴问题)

- **遇到的问题**: 渲染出的图像是上下颠倒的。
- **原因剖析**: `Data3DTexture` 没有 `flipY` 属性。在三维中，方向问题需要通过坐标操作来解决。
- **解决方案**: 在片元着色器的 `main` 函数中，对从顶点着色器传入的 `vUv` 坐标进行即时处理，在采样前将其 Y 分量翻转：`vec2 flippedUv = vec2(vUv.x, 1.0 - vUv.y);`。用这个新的 `flippedUv` 去构建三维采样坐标 `vec3(flippedUv, u_slice)`，从而得到方向正确的图像。这完美地体现了在三维渲染中通过操控坐标来控制方向的核心思想。

##### d. TypeScript Linter 错误 (`.parameters` 不存在)

- **遇到的问题**: 在 `onWindowResize` 中，`plane.geometry.parameters.width` 产生类型错误。
- **原因剖析**: 在现代 Three.js 版本中，`.parameters` 属性不再是 `BufferGeometry` 基类的可靠公开 API。
- **解决方案**: 使用官方推荐的、更健壮的方法来获取几何体尺寸：先计算其包围盒 `plane.geometry.computeBoundingBox();`，然后从包围盒中获取尺寸 `plane.geometry.boundingBox.getSize(size);`。这个方法对任何几何体都有效。
