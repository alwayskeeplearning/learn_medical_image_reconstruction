### 步骤3.5: (实践) 将序列体素数据构建为 `Data3DTexture`

这是将理论知识转化为代码的关键一步，我们成功地将一个 DICOM 序列加载并构建成了 GPU 可用的三维纹理。

---

#### 实践核心流程总结

整个过程主要包含以下几个关键步骤：

1.  **加载序列**:

    - 首先构建一个包含所有 DICOM 文件 URL 的数组。
    - 使用 `Promise.all` 和 `fetch` API 并行加载所有文件，并将它们转换为 `ArrayBuffer`。这大大提升了加载效率。

2.  **解析与提取**:

    - 遍历每个文件的 `ArrayBuffer`。
    - 使用 `dicom-parser` 解析出 `dataSet` 对象。
    - 从 `dataSet` 中提取出排序所必需的核心元数据：`ImagePositionPatient` (0020,0032)，它定义了每张切片左上角在病人坐标系中的三维物理位置。

3.  **空间排序 (至关重要的一步)**:

    - **问题**: 文件系统中的文件名顺序（如 `_0001.dcm`, `_0002.dcm`）不一定代表它们在病人身体中的真实物理顺序。直接按文件名顺序堆叠可能导致图像（例如脊柱）是错乱的。
    - **解决方案**: 我们必须进行基于物理位置的数学排序。
      - 首先，从第一张切片中获取 `ImageOrientationPatient` (0020,0037)，它定义了图像的 x 和 y 轴在病人坐标系中的方向。
      - 通过这两个方向向量的**叉乘**，我们计算出切片平面的**法向量 (normal)**。这个法向量代表了切片堆叠的精确方向（例如，从脚指向头）。
      - 然后，遍历所有切片，将每个切片的 `ImagePositionPatient` (一个三维位置向量) 与刚刚计算出的法向量进行**点积 (dot product)**。
      - 点积的结果是一个标量（一个数字），它代表了每个切片沿法线方向的投影距离。这个距离是唯一的，可以精确地描述切片的位置。
      - 最后，我们根据这个点积值，对所有切片进行升序（或降序）排序，从而获得它们在空间中正确的堆叠顺序。

4.  **构建数据体**:

    - 获取第一张（已排序）切片的宽高，以及切片的总数，来确定三维数据体的最终尺寸 (`width`, `height`, `depth`)。
    - 创建一个足够大的 `Float32Array` 来容纳所有体素数据。我们选择 `Float32Array` 是因为它能精确存储经过 `rescaleSlope` 和 `rescaleIntercept` 计算后的真实 CT 值，并且可以直接被 `FloatType` 类型的纹理使用。
    - 遍历**排好序的**切片数组，将每个切片的像素数据（应用斜率和截距转换后）依次填入这个巨大的一维数组中。

5.  **创建纹理**:
    - 调用 `new THREE.Data3DTexture()`，将构建好的 `Float32Array` 数据以及数据体的 `width`, `height`, `depth` 传入。
    - 正确设置纹理属性：`format` 设为 `THREE.RedFormat`，`type` 设为 `THREE.FloatType`，并且 `unpackAlignment` 设为 `1` 以确保数据被正确读取。

---

#### 深入问答：为什么 `Data3DTexture` 没有 `flipY` 属性？

这是一个从二维思维转向三维思维时非常重要的观念转变。

- **`flipY` 是一个二维概念**: 这个属性的本质是告诉 GPU 在上传一张**二维图片**时，颠倒数据的行顺序。这个操作对于一张图片来说是明确的。

- **三维空间的模糊性**: 对于一个三维数据体，"Y轴翻转"的定义变得模糊不清。底层的 WebGL API 本身就是为 2D 纹理设计的，对 3D 纹理不起作用。

- **三维的解决方案**: 在三维空间中，我们不再依赖 `flipY` 这样的便利属性，而是通过**数学和坐标**来完全掌控方向。
  - **数据构建时**: 我们填充 `volumeData` 数组的顺序已经定义了体素坐标系 `(i, j, k)` 的基础方向。
  - **渲染采样时**: 如果我们发现渲染出的切片是上下颠倒的，我们不应该去“翻转纹理”，而应该去调整我们的**采样坐标**。例如，在片元着色器中，将原来的纹理 `v` 坐标改为 `1.0 - v` 来进行采样，就能实现精确的垂直翻转效果。

**总结**: 从 2D 到 3D，我们对图像方向的控制，从一个简单的布尔值 `flipY`，升级为了在着色器中对**纹理坐标**的完全掌控，这给予了我们更高的自由度和灵活性。
