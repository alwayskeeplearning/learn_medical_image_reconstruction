# 步骤 2.3: 实践 - 将单张 DICOM 像素加载为 `DataTexture` 并正确显示

本步骤的核心目标是走通**数据链路**：从 DICOM 文件 -> CPU 内存 -> GPU 显存，并将数据显示在一个自适应窗口的平面上。我们通过一个循序渐进的重构过程来完成这个任务，并深入探讨了其中涉及到的 Three.js 基础知识。

## 重构第一步：最简 Three.js 场景

为了打好基础，我们首先搭建了一个只包含最核心要素的 Three.js 应用。

### Three.js 五大核心要素

这就像搭建一个舞台剧，需要五个核心元素：

1.  **场景 (`Scene`)**: 我们的“舞台”或“世界”，是所有物体的容器。

    - _类比_: 一个空空如也的摄影棚。

2.  **物体 (`Mesh`)**: 舞台上的“演员”，由两部分组成：

    - **几何体 (`Geometry`)**: 定义物体的**形状** (如 `PlaneGeometry` - 矩形)。
    - **材质 (`Material`)**: 定义物体的**外观** (如 `MeshBasicMaterial` - 基础颜色)。
    - _类比_: 一个穿着戏服的演员。“几何体”是演员的身形骨架，“材质”是他的衣服皮肤。

3.  **相机 (`Camera`)**: 观众的“眼睛”，决定观察世界的方式。我们选用 `OrthographicCamera` (正交相机)，它没有近大远小的透视效果，适合精确的2D展示。

    - _类比_: 摄影棚里的摄像机。

4.  **渲染器 (`Renderer`)**: “放映员”，负责将相机拍摄到的场景画面，计算并绘制到浏览器屏幕上。

    - _类比_: 负责冲洗胶片、生成电影画面的后期制作团队。

5.  **渲染循环 (`animate` 函数)**: 一个持续的循环，不断地告诉渲染器“重新渲染一帧”，从而让画面动起来或响应交互。
    - _类比_: 电影放映机，持续不断地将画面投射到屏幕上。

通过第一步，我们成功在屏幕上渲染了一个简单的白色方块，对这个基础流程建立了清晰的认识。

## 重构第二步：加载 DICOM 与 `DataTexture`

在基础场景之上，我们引入了真实的 DICOM 数据。

1.  **异步加载**: 使用 `async/await` 和 `fetch` API 来加载 DICOM 文件。
2.  **数据处理**: 使用 `dicom-parser` 解析文件，提取像素数据，并应用 `rescaleSlope` 和 `rescaleIntercept` 将原始整数值转换为代表真实 CT 值的 `Float32Array`。
3.  **创建纹理**: 使用这个 `Float32Array` 创建一个 `THREE.DataTexture`，并设置好格式 (`RedFormat`)、类型 (`HalfFloatType`) 和过滤器 (`NearestFilter`)。
4.  **更新物体**: 将 `MeshBasicMaterial` 的 `map` 属性设置为新创建的 `DataTexture`，使其能够将 DICOM 数据作为贴图展示出来。

### 预期结果分析 (重要)

在这一步，屏幕上最终只会显示一个**纯黑色的矩形**，而不是可见的医学图像。

- **原因**: `MeshBasicMaterial` 不知道如何将我们纹理中包含的真实 CT 值（范围可能从 -1024 到 3071）映射到屏幕上可见的灰度颜色（范围 0.0 到 1.0）。它会简单地将所有负数和零视为黑色（0.0），因此绝大部分像素都显示为黑色。
- **结论**: 看到黑色矩形，恰恰说明我们**成功**了。这证明了高精度的数据已经被无损地加载到了 GPU 显存中，只是我们还没有合适的“解码器”（即自定义 Shader）来正确地显示它。

## 重构第三步：窗口自适应 `resize` 逻辑

最后，我们实现了一个健壮的 `onResize` 函数，确保图像在任何窗口尺寸下都能被完整、不变形地显示。

### 核心问答与深入探讨

#### Q1: `plane` 的几何体尺寸是如何确定的？为什么以“高”为基准？

**回答**:
这是一个我们为了方便计算而制定的**“设计约定”**，而不是一个技术上的硬性要求。

1.  **基准点**: 我们的正交相机初始视野高度是 2 个单位（从 -1 到 1）。我们约定，让所有 DICOM 图像平面在 3D 世界里的高度也**总是 2 个单位**。这就像我们为自己的虚拟世界设定了一把“尺子”。
2.  **动态计算**: 这个约定并不依赖于图像本身是否为正方形。我们通过 `imageAspect = columns / rows` 计算出图像真实的宽高比，然后动态计算出平面应有的宽度：`planeWidth = planeHeight * imageAspect` (即 `2 * imageAspect`)。
    - **例子**: 一个 `512x400` (宽x高) 的图像，`imageAspect` 为 1.28。我们创建的平面尺寸就是 `2.56 x 2`，完美保持了原始比例。
3.  **可替代性**: 我们完全可以约定以“宽”为基准，只要相应地修改 `onResize` 逻辑，就能得到完全一样的显示效果。

#### Q2: 异步加载流程中，`onResize` 读取的 `plane.geometry` 尺寸是正确的吗？

**回答**:
是的，是正确的。这涉及到代码的**执行顺序**。

1.  **初始化**: 我们首先用一个 `1x1` 的**占位**几何体创建了 `plane` 对象。
2.  **异步加载**: `loadDicom` 函数开始异步执行。
3.  **偷梁换柱**: 在 `loadDicom` 函数**内部**，当真实的图像尺寸被解析出来后，我们用 `new THREE.PlaneGeometry(planeWidth, planeHeight)` 创建了一个**新的、尺寸正确的**几何体，并替换掉了 `plane` 对象上旧的占位几何体。
4.  **首次调用**: 在 `loadDicom` 函数的**末尾**，也就是在几何体被成功替换**之后**，我们才手动调用了 `onResize()`。
    此时，`onResize` 读取到的是已经被更新过的、正确的几何体尺寸。后续用户手动缩放窗口时，读取到的也是这个正确的尺寸。

#### Q3: `onResize` 函数中，相机视野的计算逻辑是怎样的？(以“窗口比图像更‘高’”的情况为例)

**回答**:
这是整个自适应方案的核心，其目标是让**相机最终裁剪出的视野宽高比，恰好等于窗口的宽高比**，从而避免图像拉伸。

我们用一个具体的例子来解释：

- **图像 (Plane)**: 宽幅图像，宽高比 `imageAspect` = **2.0**。根据约定，其在3D世界中的尺寸为 **4x2** (`planeWidth`=4.0, `planeHeight`=2.0)。
- **窗口 (Window)**: 手机竖屏，宽高比 `windowAspect` = **0.5**。

**代码拆解**:

1.  `camera.left = -2.0; camera.right = 2.0;`
    - **目的**: 强制规定相机的水平视野宽度必须为 4.0，正好等于图像平面的宽度。这确保了图像在水平方向上撑满视野。
2.  `camera.top = 4.0; camera.bottom = -4.0;`
    - **目的**: 根据“相机视野宽高比必须等于窗口宽高比”的铁律，反推出相机应有的垂直视野高度。
    - **推导**: `相机总宽度 / 相机总高度 = windowAspect` => `4.0 / 相机总高度 = 0.5` => `相机总高度 = 8.0`。
    - 所以，将 `top/bottom` 设置为 `4.0/-4.0`，就创造出了一个总高度为 8.0 的垂直视野。

**最终效果**: 4x2 的图像被放置在 4x8 的相机视野中央，上下自然留出空白（背景色），完美实现了“信箱模式”(Letterboxing)下的无损显示。
