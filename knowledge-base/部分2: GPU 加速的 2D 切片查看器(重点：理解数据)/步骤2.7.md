# 步骤 2.7: 实践 - 在 Fragment Shader 中实现 WW/WL（Uniform 驱动）

这是第二部分的最后一步，也是将 GPU 渲染与用户交互连接起来的关键一步。我们成功地将之前在 CPU 上实现的窗宽窗位逻辑，移植到了 GPU 的片元着色器中，实现了高性能的实时交互。

## 核心理论：着色器中的窗宽窗位

### 1. 原理回顾

窗宽窗位的本质是一个线性映射，其数学公式为：
\[
\text{output_gray} = \frac{(\text{input_ct_value} - (\text{WL} - \frac{\text{WW}}{2}))}{\text{WW}}
\]
这个公式将输入的 CT 值范围 `[WL - WW/2, WL + WW/2]` 映射到用于显示的灰度范围 `[0, 1]`。

- 低于范围下限的 CT 值，最终被“钳制”(clamp)到 0，显示为纯黑。
- 高于范围上限的 CT 值，最终被“钳制”(clamp)到 1，显示为纯白。

这个计算过程简单且独立，非常适合在 GPU 上对每个像素并行执行。

### 2. `uniform`：CPU 到 GPU 的数据桥梁

为了让 GPU 能够动态获取用户调整的窗宽(WW)和窗位(WL)值，我们使用了 `uniform` 变量：

- **JavaScript (CPU 端)**: 在 `THREE.ShaderMaterial` 的 `uniforms` 对象中定义 `u_windowWidth` 和 `u_windowLevel`。当用户操作 UI 控件时，我们更新这两个 uniform 的 `.value` 属性。
- **GLSL (GPU 端)**: 在片元着色器中声明同名的 `uniform float` 变量。这样，着色器在每次渲染时都能访问到 CPU 传递过来的最新值。

### 3. GLSL 实现

片元着色器中的核心逻辑如下：

```glsl
// 从 uniform 接收窗宽和窗位
uniform float u_windowWidth;
uniform float u_windowLevel;
uniform sampler2D u_dicomTexture;
varying vec2 vUv;

void main() {
    // 1. 采样得到原始 CT 值
    float ctValue = texture2D(u_dicomTexture, vUv).r;

    // 2. 计算窗宽定义的 CT 值下限
    float lower = u_windowLevel - u_windowWidth / 2.0;

    // 3. 应用窗宽窗位公式，将 CT 值归一化
    float normalizedValue = (ctValue - lower) / u_windowWidth;

    // 4. 使用 clamp 函数将结果严格限制在 [0.0, 1.0] 范围内
    normalizedValue = clamp(normalizedValue, 0.0, 1.0);

    // 5. 输出最终颜色
    gl_FragColor = vec4(normalizedValue, normalizedValue, normalizedValue, 1.0);
}
```

## 实践中的问题与解决方案

在实践过程中，我们遇到了两个非常典型且重要的问题。

### Q1: 为何设置肺窗（WW 1200, WL -600）后，图像显示纯白？

**现象**: 当使用专业的肺窗参数时，我们的程序渲染出纯白屏幕，而专业 DICOM 查看器能正常显示肺部细节。

**根源**: **未能正确地将原始像素值转换为亨氏单位 (Hounsfield Units, HU)**。
我在代码中错误地使用了 DICOM Tag 来获取 `Rescale Slope` (斜率) 和 `Rescale Intercept` (截距)。

- **错误 Tag**: `x00280053`, `x00280052`
- **正确 Tag**: `x00281053`, `x00281052`

**分析**:
由于使用了错误的 Tag，`dicom-parser` 无法找到对应的值，导致 `intercept` 参数回退到默认值 `0`。而对于 CT 影像，`intercept` 通常是一个关键的负数（如 -1024）。

- **正确的计算**: `HU = raw_value * slope + (-1024)`
- **错误的计算**: `HU_like = raw_value * slope + 0`

这个错误导致我们计算出的 "CT 值" 整体偏正，而肺窗关注的是一个负值区间 `[-1200, 0]`。我们错误的 CT 值全部落在了这个区间的右侧，经过 `clamp` 函数处理后，自然就全部变成了 `1.0`（纯白）。

**解决方案**: 修正代码，使用正确的 DICOM Tag `(0028,1053)` 和 `(0028,1052)` 来获取斜率和截距，确保了到 HU 值的正确转换。

### Q2: 图像为何上下颠倒？如何修复？哪种方法更好？

**现象**: 渲染出的 DICOM 影像相比原始图像是垂直翻转的。

**根源**: **不同系统间的坐标系原点定义不一致**。

- **DICOM/图像文件**: 以**左上角**为坐标原点 `(0, 0)`，Y 轴向下为正。
- **WebGL/OpenGL**: 以**左下角**为纹理坐标原点 `(0, 0)`，Y 轴（或 v 轴）向上为正。

**解决方案对比**:

#### 方法一: `texture.flipY = true` (Three.js 推荐)

- **原理**: 在 JavaScript 中设置此属性后，Three.js 会在底层调用 WebGL 的 `gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)`。这个指令告诉 GPU 在**上传纹理数据时**，直接在硬件层面完成垂直翻转。
- **执行时机**: 纹理数据上传时（一次性操作）。
- **效率**: 极高。这是 GPU 的原生功能，对渲染循环（`animate` loop）没有任何性能影响。

#### 方法二: 在片元着色器 (Fragment Shader) 中翻转

- **原理**: 在 GLSL 代码中，通过数学运算手动翻转 Y 轴的纹理坐标 `vUv.y`。
  ```glsl
  vec2 flippedUv = vec2(vUv.x, 1.0 - vUv.y);
  float ctValue = texture2D(u_dicomTexture, flippedUv).r;
  ```
- **执行时机**: **每一帧**的**每一个片元**被渲染时。
- **效率**: 稍低。虽然现代 GPU 处理一次减法运算的开销微乎其微，但这毕竟是在渲染循环中最昂贵的部分增加了不必要的、重复的计算。

**结论与最佳实践**:

| 方法                   | 执行时机             | 开销               | 推荐度                  |
| :--------------------- | :------------------- | :----------------- | :---------------------- |
| `texture.flipY = true` | 纹理上传时（一次性） | 几乎为零           | ⭐⭐⭐⭐⭐ **(首选)**   |
| Shader 中翻转          | 每帧每个片元         | 持续的微小计算开销 | ⭐⭐⭐ (可行，但非最优) |

**总结**: `texture.flipY = true` 是处理静态纹理翻转问题的最佳实践。它遵循了“在正确的时间做正确的事”的原则，在数据准备阶段就一次性解决了问题，保持了渲染循环的纯净与高效。
