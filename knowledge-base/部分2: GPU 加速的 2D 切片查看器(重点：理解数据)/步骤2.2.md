# 步骤 2.2: API - Three.js `Texture`/`DataTexture` 创建、格式/类型、`Nearest`/`Linear` 过滤器

## 1. `DataTexture` 构造函数

在 Three.js 中，创建一个 `DataTexture` 的语法如下：

```javascript
const texture = new THREE.DataTexture(data, width, height, format, type, ...);
```

### 关键参数解析

- `data`: 核心的数据源，必须是一个 `TypedArray` (例如 `Float32Array`)。数组包含了所有像素值，按从左到右、从上到下的顺序排列。
- `width`: 纹理宽度，对应 DICOM 的 `Columns` 标签 `(0028,0011)`。
- `height`: 纹理高度，对应 DICOM 的 `Rows` 标签 `(0028,0010)`。
- `format`: 数据的格式。对于单通道灰度数据，我们使用 `THREE.RedFormat`。
- `type`: 数据数组中每个元素的数据类型。为了平衡精度和性能，我们选择 `THREE.HalfFloatType`。
  - **注意**: 当我们提供 `Float32Array` 作为 `data` 并指定 `type` 为 `THREE.HalfFloatType` 时，Three.js 会在内部智能地将 32 位浮点数转换为 16 位半浮点数再上传给 GPU。

## 2. 纹理过滤器 (Filtering)

纹理过滤器决定了当纹理被放大 (`magFilter`) 或缩小 (`minFilter`) 时，GPU 如何计算屏幕像素的颜色。

### `THREE.NearestFilter` (最近邻过滤)

- **原理**: 直接选择离采样点**最近**的那个纹理像素（texel）的颜色值。
- **效果**: 图像放大时呈现清晰的、块状的“马赛克”效果。它能**完美地保留原始像素值**，不会创造出任何不存在的中间值。
- **适用场景**: **医学影像**、色彩索引图、像素画等任何要求精确、无模糊、保留原始数据值的场景。

### `THREE.LinearFilter` (线性过滤)

- **原理**: 选择离采样点最近的 4 个纹理像素，根据距离对它们的值进行加权平均，计算出一个平滑过渡的新值。
- **效果**: 图像放大时看起来更平滑、柔和，但也会显得“模糊”。
- **适用场景**: 游戏贴图、照片等追求视觉真实感的场景。

**结论**: 对于医学影像，我们**必须使用 `THREE.NearestFilter`**，以确保诊断时看到的是真实、未经修改的原始数据，避免因插值计算产生误导性信息。

## 3. 示例代码

```javascript
// 假设已从 DICOM 解析并处理好数据
const width = 512;
const height = 512;
const ctValues = new Float32Array(width * height); // 填充了真实的CT值

// 1. 创建 DataTexture
const texture = new THREE.DataTexture(ctValues, width, height, THREE.RedFormat, THREE.HalfFloatType);

// 2. 设置纹理过滤器
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestFilter;

// 3. 通知 Three.js 数据已更新，需要重新上传到 GPU
texture.needsUpdate = true;
```

---

## 问答与深入探讨

### Q1: `texture.needsUpdate = true` 是在什么时候需要设置？是因为设置了 `magFilter` 和 `minFilter` 吗？

**回答**: 不是。`texture.needsUpdate` 与 `magFilter`/`minFilter` 等采样参数的设置无关。

- **`texture.needsUpdate` 的作用**: 它的唯一作用是告诉 Three.js：“纹理的**数据内容 (`.data`) 本身**已经发生了改变，请将新的数据从 CPU 内存重新上传到 GPU 显存。”
- **采样参数 (`magFilter`等) 的作用**: 它们只是告诉 GPU 在读取**已经存在于显存中**的数据时，应该遵循什么样的采样规则。改变规则不需要重新上传数据。

### Q2: `new THREE.DataTexture(...)` 会立即将数据上传到 GPU 吗？

**回答**: 不会立即上传。

- `new THREE.DataTexture(...)` 只是在 CPU 侧（JavaScript 环境中）创建了一个对象。
- 真正的数据上传操作发生在 **Three.js 的渲染循环中**。当渲染器准备绘制一个使用了该纹理的物体时，它会检查到这是一个新纹理（或 `needsUpdate` 为 `true`），此时才会触发 WebGL API 将数据从 CPU 传送至 GPU。

**为什么在初次创建后也要设置 `needsUpdate = true`？**

这是一种**明确的信号**和**最佳实践**。

1.  **明确性**: 清晰地告知渲染引擎，数据已就绪，应在下一帧上传。
2.  **建立习惯**: **这至关重要**。在未来，任何时候当你通过代码修改了纹理的数据（例如 `texture.image.data[i] = ...` 或切换到新的切片数据），你**必须**手动设置 `texture.needsUpdate = true`，否则 GPU 将继续使用旧的缓存数据，屏幕上的图像不会更新。因此，在创建时就加上它，是在为后续的动态更新建立一个正确且必需的编码习惯。
