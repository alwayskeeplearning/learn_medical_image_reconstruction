# 步骤 2.5: API - Three.js `ShaderMaterial`、`Uniforms` 管理

理论学习完毕后，我们需要一个工具将 GLSL 代码“装载”到 Three.js 中。这个工具就是 `ShaderMaterial`。它允许我们完全接管 GPU 的渲染管线，使用自定义的着色器代码。

## 1. `ShaderMaterial` 构造函数

创建一个 `ShaderMaterial` 需要传入一个配置对象，其中最重要的三个属性是：

```javascript
const myCustomMaterial = new THREE.ShaderMaterial({
  uniforms: myUniforms,
  vertexShader: myVertexShaderCode,
  fragmentShader: myFragmentShaderCode,
});
```

- `vertexShader`: 包含顶点着色器 GLSL 代码的**字符串**。
- `fragmentShader`: 包含片元着色器 GLSL 代码的**字符串**。
- `uniforms`: 一个定义了如何从 CPU 传递数据到 GPU 的 **JavaScript 对象**。

## 2. `uniforms` 对象

`uniforms` 对象是连接 JS 和 GLSL 的核心桥梁，其结构非常特定：

- 对象的**键**必须与 GLSL 中 `uniform` 变量名**完全一致**。
- 对象对应的**值**也是一个对象，该对象必须有一个 `value` 属性，`value` 属性的值才是真正要传递的数据。

```javascript
// GLSL (Fragment Shader)
// uniform float u_windowCenter;

// JavaScript
const myUniforms = {
  u_windowCenter: { value: 40.0 },
};

// 后续更新 uniform 值
myUniforms.u_windowCenter.value = 60.0;
```

这种 `{ value: ... }` 的包装是 Three.js 的设计，用于在内部高效地跟踪 `uniform` 值的变化。

## 3. Three.js 内置的 `attribute` 和 `uniform`

使用 `ShaderMaterial` 时，Three.js 会自动为我们的 Shader 注入一些非常有用的内置变量，我们无需手动传入。

- **自动注入的 `attribute` (供 VS 使用)**:

  - `vec3 position`: 顶点的模型坐标。
  - `vec2 uv`: 顶点的 UV 坐标。**这正是 `vUv = uv;` 这句代码的 `uv` 的来源！**

- **自动注入的 `uniform` (供 VS 使用)**:
  - `mat4 modelViewMatrix`: **模型视图矩阵**。
  - `mat4 projectionMatrix`: **相机投影矩阵**。

这使得我们可以直接编写经典的顶点变换代码：
`gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);`

---

## 问答与深入探讨

### Q1: `gl_Position` 的计算中，为什么没有看到完整的 MVP (Model-View-Projection) 矩阵？

**回答**:
这是一个非常专业的观察。`M`、`V`、`P` 三个矩阵一个都不少，只是 **Three.js 为了效率，在 CPU 端预先将 Model 和 View 两个矩阵合并了**。

- **完整变换链**: `gl_Position = Projection * View * Model * vec4(position, 1.0);`
- **Three.js 的优化**: 在渲染一个物体前，Three.js 会在 CPU 端预先计算 `View * Model` 的结果，生成一个新的矩阵，并将其命名为 `modelViewMatrix` 传入 Shader。

这样做的好处是**减少了 GPU 的计算量**，尤其是在顶点数量多的模型上，这个优化非常可观。

### Q2: 为什么说 Model 和 View 矩阵在一次渲染中是不变的，而 Projection 矩阵是“变的”？

**回答**:
这个问题的核心在于理解“变”与“不变”的**参照系**和**时间尺度**。我们用一个“拍摄定格动画”的例子来解释：

- **场景**: 一个房间（世界空间），里面有一张桌子和一个茶壶（物体），以及一台固定的摄像机（相机）。
- **单次渲染调用**: 相当于按下快门，拍摄**一张**照片的瞬间。

1.  **Model Matrix (模型矩阵)**:

    - **描述**: 茶壶在房间里的位置、旋转、缩放。
    - **不变性**: 在“按下快门”的这一瞬间，茶壶本身是静止的。因此，对于构成茶壶的所有顶点而言，它们的 `Model` 矩阵是**统一且不变**的。

2.  **View Matrix (视图矩阵)**:

    - **描述**: 摄像机在房间里的位置和朝向。
    - **不变性**: 在“按下快门”的这一瞬间，摄像机的位置也是固定的。因此，`View` 矩阵对于本次拍摄的所有物体都是**统一且不变**的。

    > 正因为在单次渲染调用中，`Model` 和 `View` 矩阵对于同一个物体的所有顶点都是恒定的，Three.js 才能安全地将它们预乘为 `modelViewMatrix`。

3.  **Projection Matrix (投影矩阵)**:
    - **描述**: 摄像机的“镜头”属性，即它的视野范围（宽度、高度、远近）。
    - **“善变”性**: 它的“变”不是指在一次快门中变化，而是指在**整个应用的生命周期中，它最容易因为外部因素而改变**。
    - **例子**:
      - 当用户**拖拽改变浏览器窗口大小**时，我们的 `onResize` 函数就会被触发。
      - 在 `onResize` 中，我们会修改 `camera` 的 `left`, `right`, `top`, `bottom` 属性。
      - 最后，我们必须调用 `camera.updateProjectionMatrix()`，这个函数会根据新的视野参数，**重新计算出一个全新的 `Projection` 矩阵**。
      - 同样，如果我们通过鼠标滚轮实现视野缩放 (`camera.zoom`)，也会频繁地导致 `Projection` 矩阵的重新计算。

**总结表格**

| 矩阵           | 描述对象              | 在**单次渲染**中是否变化？ | 在**应用运行期间**是否经常变化？ |
| :------------- | :-------------------- | :------------------------- | :------------------------------- |
| **Model**      | 物体在世界中的状态    | **不变**                   | 变 (当物体移动/旋转时)           |
| **View**       | 相机在世界中的状态    | **不变**                   | 变 (当相机移动/旋转时)           |
| **Projection** | 相机的“镜头”属性/视野 | **不变**                   | **经常变** (窗口缩放, 视野缩放)  |
