# 步骤 2.4: 理论 - GLSL 基础 (VS/FS, Uniform, Sampler)

当我们使用的 `MeshBasicMaterial` 等预置材质无法满足需求时（例如实现自定义的窗宽窗位逻辑），我们就需要自己编写**着色器 (Shader)** 代码。

## 1. 什么是 Shader？

Shader 是在 GPU 上运行的小程序，使用一种类 C 的语言 **GLSL (OpenGL Shading Language)** 编写。它允许我们利用 GPU 大规模并行计算的能力，为渲染的每个顶点和每个像素进行自定义计算。主要涉及两种 Shader：

### 顶点着色器 (Vertex Shader - VS)

- **职责**: 计算顶点的最终屏幕位置。
- **执行次数**: 为物体的**每一个顶点**执行一次。对于一个由4个顶点构成的 `PlaneGeometry`，它就执行4次。
- **输入**: 单个顶点的原始数据（如模型坐标），以及全局的变换矩阵等。
- **输出**: 该顶点在屏幕上的最终裁剪坐标（一个名为 `gl_Position` 的内置变量）。
- **类比**: **造型师**。负责把我们矩形的四个角（顶点）拉到屏幕上的正确位置，搭好一个“画框”。

### 片元着色器 (Fragment Shader - FS)

- **职责**: 计算一个像素的最终颜色。
- **执行次数**: 在顶点着色器确定物体轮廓后，GPU 会进行光栅化，为轮廓覆盖的**每一个像素**都执行一次片元着色器。如果一个平面覆盖了 512x512 个像素，FS 就会执行 262,144 次。
- **输入**: 当前像素的坐标信息（如 UV 坐标），以及从 JS 或 VS 传来的数据。
- **输出**: 该像素最终应该显示的颜色（一个名为 `gl_FragColor` 的内置变量）。
- **类比**: **填色师**。负责为“画框”里的每一个像素点，计算出它应该填什么颜色。

## 2. GLSL 中的三种核心变量类型

数据从 CPU 到达最终的片元着色器，需要通过三种不同的“数据管道”。我们可以将其想象成一个“邮件投递系统”。

### `attribute` (属性) - “每个收件人独有的包裹”

- **定义**: **只在顶点着色器 (VS) 中可用**，代表与**单个顶点**相关的专属数据。
- **数据来源**: CPU 端的几何体数据 (`BufferGeometry`)，例如顶点位置、法线、**UV坐标**。
- **特点**:
  - **VS 专属**: 片元着色器 (FS) 无法访问。
  - **每个顶点都不同**: 顶点A 和顶点B 的 `attribute` 值是不同的。
- **核心作用**: 描述单个顶点的属性。

### `uniform` (全局变量) - “所有人都收到的广播通知”

- **定义**: 在 **VS 和 FS 中都可用**，代表对于一次完整的渲染命令而言，值恒定不变的数据。
- **数据来源**: CPU 端的 JavaScript 代码，例如我们即将传入的窗宽 (`u_windowWidth`)、窗位 (`u_windowCenter`)，以及我们的 DICOM 纹理 (`sampler2D`)。
- **特点**:
  - **VS 和 FS 共享**。
  - **全局统一**: 在一次渲染中，所有顶点和所有片元访问到的 `uniform` 值都完全相同。
- **核心作用**: 从 JS 传递全局参数到 Shader。

### `varying` (可变/插值变量) - “从造型师传给填色师的便签”

- **定义**: 连接 **VS 和 FS 的桥梁**。它在 VS 中被写入，在 FS 中被读取。
- **数据来源**: 顶点着色器 (VS) 的计算结果。
- **工作原理 (插值)**: 这是 `varying` 最神奇的特性。
  1.  VS 为每个顶点计算出一个 `varying` 值（例如，将顶点的 `attribute uv` 赋值给 `varying vUv`）。
  2.  光栅化硬件会根据片元在顶点之间的位置，自动地、平滑地**计算出一个“中间”的 `varying` 值**。
  3.  FS 接收到这个**已经被插值过的、每个像素都独一无二的**值。
- **核心作用**: 将数据从 VS **平滑地**传递到 FS。

### 数据流转总结

`vUv` (纹理坐标) 的完整旅程清晰地展示了三者的协作：
**`CPU (attribute uv)` -> `VS (varying vUv)` -> `光栅器 (插值)` -> `FS (varying vUv)`**

这个流程确保了片元着色器中拿到的 `vUv`，就是当前像素在纹理上精确的百分比位置。

### 总结表格

| 变量类型        | 数据来源             | 在哪个 Shader 中可读？               | 每个实例的值是否不同？      | 核心作用                              |
| :-------------- | :------------------- | :----------------------------------- | :-------------------------- | :------------------------------------ |
| **`attribute`** | CPU (几何体顶点数据) | **仅** Vertex Shader                 | **是** (每个顶点不同)       | 描述单个顶点的属性 (位置, UV等)       |
| **`uniform`**   | CPU (JS代码传入)     | Vertex Shader **和** Fragment Shader | **否** (一次渲染中完全相同) | 传递全局参数 (相机矩阵, 窗宽, 时间等) |
| **`varying`**   | Vertex Shader        | **仅** Fragment Shader               | **是** (每个片元都经过插值) | 将数据从 VS 平滑地传递到 FS           |

**注意**: 在现代 GLSL (WebGL2/ES 3.0) 中，`attribute` 被 `in` 替代，`varying` 被 VS 中的 `out` 和 FS 中的 `in` 所替代。但理解其概念和数据流是共通的。

## 3. `Sampler` (采样器)

`Sampler` 是一种特殊的 `uniform`，它代表了 GPU 显存中的一块纹理。

- **声明**: 在 GLSL 中，我们用 `uniform sampler2D u_dicomTexture;` 来声明一个2D纹理采样器。
- **使用**: 我们使用 GLSL 的内置函数 `texture2D(sampler, uv)`，传入采样器和经 `varying` 传递过来的 `vUv` 坐标，就可以从纹理的对应位置读取数据。
- **读取高精度数据**: 由于我们创建 `DataTexture` 时使用的 `format` 是 `RedFormat`，采样返回的是一个 `vec4` 向量，其 `r, g, b, a` 四个分量的值**都等于**我们存入的原始 CT 值。例如，如果某个像素的 CT 值是 -100，那么 texColor 的值就是 vec4(-100.0, -100.0, -100.0, -100.0)。我们只需读取 `r` 分量 (`.r`)，即可在片元着色器中获得该像素精确的 CT 值，为后续的窗宽窗位计算做好准备。
