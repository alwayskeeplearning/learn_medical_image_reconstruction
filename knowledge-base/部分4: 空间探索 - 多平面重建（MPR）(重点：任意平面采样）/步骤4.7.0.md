# 步骤 4.7.0: 理论 - 矩阵乘法顺序：局部坐标系 vs 世界坐标系

这是在实现旋转十字线功能时遇到的一个核心理论问题。

## 用户问题

在代码中，`multiplyMatrices(config.dragStartMatrix, rotationMatrix)` 和 `multiplyMatrices(rotationMatrix, config.dragStartMatrix)` 这两种写法有什么区别？

## 核心解答

这是一个非常核心且关键的矩阵数学问题，理解这两者的区别是掌握3D变换的关键。它们代表了完全不同的操作意图和结果。

我们用 `M_start` 代表 `config.dragStartMatrix` （物体的初始状态），用 `R_delta` 代表 `rotationMatrix` （我们想施加的旋转增量）。

---

### 1. `multiplyMatrices(M_start, R_delta)` (后乘/Post-multiplication)

**数学公式**: `M_new = M_start * R_delta`

**物理意义**: **在物体的局部坐标系（Local Space）下进行变换。**

**直观解释**:
想象一下，你是一个驾驶着飞机的飞行员（`M_start` 定义了飞机当前的位置和朝向）。
`R_delta` 是一个“向左转30度”的指令。
当执行 `M_start * R_delta` 时，你会在你**当前**的朝向上，以**飞机头**为参考，向左转30度。如果你的飞机是倒着飞的，那你就会以倒着的姿态，机头向“左”转。

**在我们的代码中**:
`config.matrix.multiplyMatrices(config.dragStartMatrix, rotationMatrix);`
这行代码意味着：

1.  取来十字线在拖拽开始时的状态 `M_start`。
2.  然后，在 `M_start` 所定义的那个（可能已经平移和旋转过的）坐标系里，再进行 `R_delta` 旋转。
3.  这正是我们最初实现旋转功能时遇到“不跟手”问题的原因：鼠标手势是在屏幕（世界）坐标系里定义的旋转，而这个操作却在物体的局部坐标系里执行，当两个坐标系不统一时，结果就不符合直觉。

---

### 2. `multiplyMatrices(R_delta, M_start)` (前乘/Pre-multiplication)

**数学公式**: `M_new = R_delta * M_start`

**物理意义**: **在世界坐标系（World Space）或父坐标系下进行变换。**

**直观解释**:
还是那个飞机。现在你不是飞行员了，你是一个在地面塔台的**观察者**。
`M_start` 依然是飞机当前的状态。
`R_delta` 依然是“向左转30度”的指令。
当执行 `R_delta * M_start` 时，你作为观察者，会看到整个飞机（连同它自己内部的坐标系）围绕着**世界坐标系的原点**（或者某个父节点），旋转了30度。飞机本身并没有“主动”转向，而是被一个外部的力量给“扳”了过去。

**在我们的代码中**:
如果我们写成 `config.matrix.multiplyMatrices(rotationMatrix, config.dragStartMatrix);`
这将意味着：

1.  取来十字线在拖拽开始时的状态 `M_start`。
2.  然后，让这个十字线整体围绕着**世界坐标系的原点(0,0,0)**（在我们的场景里就是DOM元素的左下角）进行 `R_delta` 旋转。
3.  这会导致十字线在旋转的同时，还会产生一个巨大的“公转”位移，因为它不是围绕自己的中心旋转，所以这种方法也是不正确的。

---

### 总结表格

| 特性                 | `M_start * R_delta` (后乘)                                 | `R_delta * M_start` (前乘)                                 |
| :------------------- | :--------------------------------------------------------- | :--------------------------------------------------------- |
| **坐标系**           | **局部坐标系 (Local Space)**                               | **世界/父坐标系 (World Space)**                            |
| **变换顺序生效**     | 先 `M_start`，再 `R_delta`                                 | 先 `R_delta`，再 `M_start`                                 |
| **直观感受**         | 物体**自身**的变换（如坦克炮塔旋转）                       | 物体被**外部**力量变换（如地球绕太阳公-转）                |
| **Three.js API**     | `object.rotateX()` 等方法就是后乘                          | `object.position.set()` 是在父空间中操作                   |
| **我们代码中的情况** | `multiplyMatrices(config.dragStartMatrix, rotationMatrix)` | `multiplyMatrices(rotationMatrix, config.dragStartMatrix)` |

在Three.js中，矩阵乘法的顺序是从右向左依次施加变换的。

- `M_new = M_1 * M_2 * M_3`: 对一个向量`v`应用变换时，是 `M_1 * (M_2 * (M_3 * v)))`，即最右边的`M_3`最先生效。
- `multiplyMatrices(A, B)` 在Three.js中执行的是 `this.matrix = A * B`。

理解这个顺序对于正确应用变换至关重要。
