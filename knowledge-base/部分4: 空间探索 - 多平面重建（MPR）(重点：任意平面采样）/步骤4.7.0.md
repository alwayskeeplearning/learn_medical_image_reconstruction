# 步骤 4.7.0: 理论 - 矩阵乘法顺序：局部坐标系 vs 世界坐标系

这是在实现旋转十字线功能时遇到的一个核心理论问题。

## 用户问题

在代码中，`multiplyMatrices(config.dragStartMatrix, rotationMatrix)` 和 `multiplyMatrices(rotationMatrix, config.dragStartMatrix)` 这两种写法有什么区别？

## 核心解答

这是一个非常核心且关键的矩阵数学问题，理解这两者的区别是掌握3D变换的关键。它们代表了完全不同的操作意图和结果。

我们用 `M_start` 代表 `config.dragStartMatrix` （物体的初始状态），用 `R_delta` 代表 `rotationMatrix` （我们想施加的旋转增量）。

---

### 1. `multiplyMatrices(M_start, R_delta)` (后乘/Post-multiplication)

**数学公式**: `M_new = M_start * R_delta`

**物理意义**: **在物体的局部坐标系（Local Space）下进行变换。**

**直观解释**:
想象一下，你是一个驾驶着飞机的飞行员（`M_start` 定义了飞机当前的位置和朝向）。
`R_delta` 是一个“向左转30度”的指令。
当执行 `M_start * R_delta` 时，你会在你**当前**的朝向上，以**飞机头**为参考，向左转30度。如果你的飞机是倒着飞的，那你就会以倒着的姿态，机头向“左”转。

**在我们的代码中**:
`config.matrix.multiplyMatrices(config.dragStartMatrix, rotationMatrix);`
这行代码意味着：

1.  取来十字线在拖拽开始时的状态 `M_start`。
2.  然后，在 `M_start` 所定义的那个（可能已经平移和旋转过的）坐标系里，再进行 `R_delta` 旋转。
3.  这正是我们最初实现旋转功能时遇到“不跟手”问题的原因：鼠标手势是在屏幕（世界）坐标系里定义的旋转，而这个操作却在物体的局部坐标系里执行，当两个坐标系不统一时，结果就不符合直觉。

---

### 2. `multiplyMatrices(R_delta, M_start)` (前乘/Pre-multiplication)

**数学公式**: `M_new = R_delta * M_start`

**物理意义**: **在世界坐标系（World Space）或父坐标系下进行变换。**

**直观解释**:
还是那个飞机。现在你不是飞行员了，你是一个在地面塔台的**观察者**。
`M_start` 依然是飞机当前的状态。
`R_delta` 依然是“向左转30度”的指令。
当执行 `R_delta * M_start` 时，你作为观察者，会看到整个飞机（连同它自己内部的坐标系）围绕着**世界坐标系的原点**（或者某个父节点），旋转了30度。飞机本身并没有“主动”转向，而是被一个外部的力量给“扳”了过去。

**在我们的代码中**:
如果我们写成 `config.matrix.multiplyMatrices(rotationMatrix, config.dragStartMatrix);`
这将意味着：

1.  取来十字线在拖拽开始时的状态 `M_start`。
2.  然后，让这个十字线整体围绕着**世界坐标系的原点(0,0,0)**（在我们的场景里就是DOM元素的左下角）进行 `R_delta` 旋转。
3.  这会导致十字线在旋转的同时，还会产生一个巨大的“公转”位移，因为它不是围绕自己的中心旋转，所以这种方法也是不正确的。

---

### 总结表格

| 特性                 | `M_start * R_delta` (后乘)                                 | `R_delta * M_start` (前乘)                                 |
| :------------------- | :--------------------------------------------------------- | :--------------------------------------------------------- |
| **坐标系**           | **局部坐标系 (Local Space)**                               | **世界/父坐标系 (World Space)**                            |
| **变换顺序生效**     | 先 `M_start`，再 `R_delta`                                 | 先 `R_delta`，再 `M_start`                                 |
| **直观感受**         | 物体**自身**的变换（如坦克炮塔旋转）                       | 物体被**外部**力量变换（如地球绕太阳公-转）                |
| **Three.js API**     | `object.rotateX()` 等方法就是后乘                          | `object.position.set()` 是在父空间中操作                   |
| **我们代码中的情况** | `multiplyMatrices(config.dragStartMatrix, rotationMatrix)` | `multiplyMatrices(rotationMatrix, config.dragStartMatrix)` |

在Three.js中，矩阵乘法的顺序是从右向左依次施加变换的。

- `M_new = M_1 * M_2 * M_3`: 对一个向量`v`应用变换时，是 `M_1 * (M_2 * (M_3 * v)))`，即最右边的`M_3`最先生效。
- `multiplyMatrices(A, B)` 在Three.js中执行的是 `this.matrix = A * B`。

理解这个顺序对于正确应用变换至关重要。

---

# 附录: 如何计算 3D 物体在屏幕上的像素尺寸

在实现 MPR 与十字线 UI 融合时，一个核心问题是：如何知道 3D 场景中的 `plane`（代表一个医学影像切片）最终在浏览器屏幕上占据了多少像素？

直接使用 `plane` 的 `width` 或 `scale` 是不行的，因为那是它在 3D 世界（单位：毫米）中的尺寸。我们需要一个方法，将 3D 坐标转换为 2D 屏幕像素坐标。

`getPlanePixelSize` 函数正是为此设计的，它通过完整模拟 GPU 的渲染坐标变换管线来得到精确结果。

## 渲染坐标变换流程详解

GPU 将一个 3D 模型的顶点渲染到 2D 屏幕上，需要经过一系列坐标系的转换。这个流程就像一个“翻译”链条，把模型自己的语言（局部坐标）一步步翻译成屏幕能懂的语言（像素坐标）。

**流程概览: `局部坐标` -> `世界坐标` -> `视图坐标` -> `裁剪坐标` -> `NDC 坐标` -> `屏幕像素坐标`**

下面我们以 `plane` 的一个顶点为例，看看它经历了怎样的旅程：

### 1. 局部坐标 (Local Space)

- **是什么**: 这是模型被创建时的坐标系，也叫模型坐标（Model Space）。`plane` 的几何体（`PlaneGeometry`）的顶点 `position` 属性，就是在这个坐标系下定义的。原点 `(0,0,0)` 通常是模型的几何中心。
- **`getPlanePixelSize` 中的体现**:
  ```javascript
  const positions = geom.attributes.position;
  const corners = [
    new Vector3(positions.getX(0), ...),
    ...
  ];
  ```
  我们从 `geometry` 中直接读取顶点的 `x, y, z` 值，这就是它们的局部坐标。

### 2. 世界坐标 (World Space)

- **是什么**: 这是整个 3D 场景的“公共”坐标系。场景中所有的物体（模型、相机、灯光）都有自己在这个世界中的位置、旋转和缩放。通过一个**模型矩阵 (Model Matrix)** (`mesh.matrixWorld`)，可以将一个物体的局部坐标转换到世界坐标。
- **`getPlanePixelSize` 中的体现**:
  ```javascript
  mesh.updateWorldMatrix(true, false);
  const worldCorner = corner.clone().applyMatrix4(mesh.matrixWorld);
  ```
  我们调用 `applyMatrix4(mesh.matrixWorld)`，将局部坐标 `corner` 乘以模型矩阵，得到了它在世界场景中的位置 `worldCorner`。

### 3. 视图坐标 (View Space)

- **是什么**: 这是以相机为中心的坐标系，也叫相机坐标（Camera Space）。在这个坐标系下，相机位于原点 `(0,0,0)`，并看向 Z 轴的负方向。通过一个**视图矩阵 (View Matrix)** (`camera.matrixWorldInverse`)，可以将世界坐标转换到视图坐标。
- **在 Three.js 中的简化**: Three.js 的 `vector.project(camera)` 方法非常方便，它将第 3 步（转视图坐标）、第 4 步（转裁剪坐标）和第 5 步（转 NDC 坐标）合并成了一步操作，我们无需手动计算视图矩阵。

### 4. 裁剪坐标 (Clip Space)

- **是什么**: 经过**投影矩阵 (Projection Matrix)** (`camera.projectionMatrix`) 变换后，顶点就进入了裁剪坐标系。这个矩阵定义了相机的可视范围（即“视锥体” Frustum）。所有在视锥体外部的顶点都将被“裁剪”掉，不会被渲染。
- **在 Three.js 中的简化**: 同样被包含在 `vector.project(camera)` 方法内部。

### 5. 归一化设备坐标 (Normalized Device Coordinates, NDC)

- **是什么**: 这是对裁剪坐标进行“透视除法”后的结果，将 `x, y, z` 坐标都映射到一个 `[-1, 1]` 的标准立方体中。这个坐标系与屏幕分辨率无关，是渲染流程中的一个标准中间步骤。
- **`getPlanePixelSize` 中的体现**:
  ```javascript
  const ndcCorner = worldCorner.clone().project(camera);
  ```
  `project(camera)` 方法内部执行了 `视图矩阵` 和 `投影矩阵` 的乘法，以及透视除法，直接将世界坐标 `worldCorner` 转换为了 NDC 坐标 `ndcCorner`。此时 `ndcCorner.x` 和 `ndcCorner.y` 的值都在 `[-1, 1]` 区间内。

### 6. 屏幕像素坐标 (Screen Space)

- **是什么**: 这是我们最终看到的，以像素为单位的 2D 屏幕坐标。转换很简单，就是将 `[-1, 1]` 的 NDC 坐标线性映射到 `[0, canvas.width]` 和 `[0, canvas.height]` 的范围。
- **`getPlanePixelSize` 中的体现**:

  ```javascript
  const canvasWidth = canvas.clientWidth;
  const canvasHeight = canvas.clientHeight;

  const screenX = ((ndcCorner.x + 1) / 2) * canvasWidth;
  const screenY = ((-ndcCorner.y + 1) / 2) * canvasHeight; // Y轴需要翻转
  ```

  - `(ndcCorner.x + 1) / 2` 将 `[-1, 1]` 映射到 `[0, 1]`。
  - 乘以 `canvasWidth` 得到最终的 x 像素坐标。
  - Y 轴比较特殊，因为 NDC 的 `+1` 是“上”，而屏幕坐标的 `+y` 通常是“下”，所以我们需要用 `-ndcCorner.y` 来进行翻转。

## 总结

通过以上六个步骤，`getPlanePixelSize` 函数精确地计算出了 `plane` 四个角点在屏幕上的像素位置，然后通过取 `min/max` 值得到一个包围盒，从而计算出其最终的像素宽高。这个方法不仅适用于正交相机，也同样适用于透视相机，是连接 3D 渲染与 2D UI 交互的桥梁。
