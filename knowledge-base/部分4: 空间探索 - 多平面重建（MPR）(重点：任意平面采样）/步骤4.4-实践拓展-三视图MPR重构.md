# 步骤4.4 实践拓展：三视图MPR重构与对比学习

## 1. 重构动机：为十字线工具准备舞台

在正式进入十字线工具（`Crosshair`）的理论学习前，我们意识到，一个将所有视图渲染在同一个3D空间内的MPR实现，不利于后续的二维交互。一个真正的医学影像工作站，其核心是独立但联动的多视图（三视图）布局。

因此，我们决定先暂停原计划，动手将之前的统一3D空间MPR，重构为一个经典的三视图（Axial, Sagittal, Coronal）正交MPR布局，为后续所有交互功能打下坚实的基础。

## 2. 方案一：单 `Renderer` + 多 `Viewport` 实现

这是我们实现的第一版，也是性能更优、更工业化的版本。

### 2.1. 核心架构

- **HTML 结构**：使用CSS Grid或Flexbox创建三个独立的`<div>`容器，用于在页面上“占位”，规划出三个视图的布局区域。
- **渲染机制**：
  - 全局只创建一个`WebGLRenderer`实例和一个`<canvas>`元素。
  - 该`<canvas>`通过CSS绝对定位，覆盖在所有`<div>`的上层，像一张透明的画板。
  - **为每个视图创建独立的`Scene`和`OrthographicCamera`**。
  - 在渲染循环（`animate`函数）中，依次为每个视图执行以下操作：
    1.  通过`div.getBoundingClientRect()`获取其在页面上的位置和大小。
    2.  调用`renderer.setViewport()`和`renderer.setScissor()`，将渲染区域限定在这个`div`对应的矩形内。
    3.  使用该视图对应的`camera`渲染对应的`scene`。

### 2.2. 关键API深度解析：`setViewport` vs `setScissor`

这是理解该方案的钥匙。

- **`renderer.setViewport(x, y, width, height)`**:

  - **作用**: 定义“照片”的位置和大小。它告诉渲染器，把相机拍摄到的内容，最终**贴在**画布的哪个矩形区域里。
  - **类比**: 像在PPT里调整一张图片的位置和大小。
  - **效果**: 它负责将三维场景**映射**到二维画布的指定区域。

- **`renderer.setScissor(x, y, width, height)`**:
  - **作用**: 定义“裁剪”的区域。它告诉渲染器，**只允许**在这个矩形区域内进行绘制，超出部分将被丢弃。
  - **类比**: 像盖在画纸上的镂空模板，只允许在镂空处作画。
  - **关键配合**: `setScissor`最重要的作用是**保护其他区域不被`renderer.clear()`意外擦除**。当开启`scissor test`后，`clear`操作只会清空裁剪框内的区域，从而保证了多个视图在同一画布上渲染时互不干扰。

**总结表格**

| 函数                     | 作用                                     | 类比                        | 关键点                                  |
| :----------------------- | :--------------------------------------- | :-------------------------- | :-------------------------------------- |
| `renderer.setViewport()` | **映射**：把场景输出“贴”到画布的指定位置 | 在PPT里设置图片的位置和大小 | 决定了最终图像的**显示区域**            |
| `renderer.setScissor()`  | **裁剪**：限制绘制操作的“作画区域”       | 盖在画纸上的镂空模板        | 保护其他区域不被 `clear` 等操作意外擦除 |

### 2.3. `Resize` (窗口缩放) 逻辑

多视图下的`resize`比单视图复杂，核心是保证医学影像**不因窗口或`div`的宽高比变化而变形**。

1.  **`handleResize()` (宏观)**: 监听窗口变化，只做两件事：更新全局`renderer`的尺寸，然后通知每个视图去独立更新自己。
2.  **`updateView()` (微观)**: 每个视图独立执行：
    a. 获取自身`div`的宽高。
    b. 获取自身渲染的医学切片的物理宽高。
    c. **比较`div`和切片的宽高比**，以决定是“以宽为准”还是“以高为准”来计算相机的视锥体，从而确保图像始终保持正确的比例，多余的部分留出黑边。
    d. 更新正交相机的`left`, `right`, `top`, `bottom`属性。

## 3. 方案二：多 `Renderer` + 共享 `Texture` (对比学习)

为了深化理解，我们实现了第二套方案作为对比。

### 3.1. 核心架构

- **HTML 结构**：每个视图`<div>`内部都包含一个自己的`<canvas>`元素。
- **渲染机制**：
  - **为每个视图创建独立的`WebGLRenderer`**，并绑定到其专属的`<canvas>`上。
  - `Scene`和`Camera`依然是每个视图一套。
  - **`Data3DTexture`只创建一次**，然后将其引用共享给三个视图的`ShaderMaterial`。WebGL允许在同一页面进程的不同渲染上下文之间共享GPU资源。
  - `animate`函数变得极其简单，只需遍历所有视图，调用各自的`renderer.render()`即可，不再需要`viewport`和`scissor`。
  - `resize`逻辑也相应地分散到每个视图中，各自管理自己的`renderer`尺寸和`camera`视锥体。

### 3.2. 两种方案对比总结

| 特性           | 单 Renderer 方案 (方案一)                                    | 多 Renderer 方案 (方案二)                                 |
| :------------- | :----------------------------------------------------------- | :-------------------------------------------------------- |
| **代码复杂度** | `animate` 和 `resize` 逻辑较复杂 (需要 `viewport`/`scissor`) | `animate` 和 `resize` 逻辑更分散、更直观                  |
| **初始化开销** | **低**。只创建一个 WebGL 上下文。                            | **高**。创建三个独立的 WebGL 上下文，每个都有相当的开销。 |
| **运行时性能** | **高**。GPU 无需切换上下文，效率更高。                       | **较低**。频繁切换 WebGL 上下文可能会带来性能损耗。       |
| **资源管理**   | 简单，所有资源都在一个上下文中。                             | 需要注意跨上下文的资源共享。                              |
| **适用场景**   | 高性能、复杂布局的专业应用。                                 | 简单应用、快速原型或页面中不同组件需要隔离渲染的场景。    |

## 4. 关键修正：`Slice Thickness` vs `Spacing Between Slices`

在实践中，我们发现冠状位和矢状位视图有被“压扁”的现象。这暴露出一个DICOM数据处理中的常见陷阱。

- **问题根源**: 代码最初使用`Slice Thickness` (层厚) 乘以切片数来计算体数据的总高度。但这忽略了**层间距**可能与层厚不同。
- **三种扫描方式**:
  1.  **有间隙扫描 (Gapped)**: `层厚 < 层间距` (我们遇到的情况)
  2.  **连续扫描 (Contiguous)**: `层厚 = 层间距`
  3.  **重叠扫描 (Overlapping)**: `层厚 > 层间距` (用于高质量三维重建)
- **最终的稳健方案**: 放弃依赖不一定可靠的`Slice Thickness`标签，改为通过已排序切片的`ImagePositionPatient`标签，**直接计算相邻两张切片中心点的三维空间距离**。
  ```typescript
  const pos0 = new THREE.Vector3().fromArray(sortedSlices[0].imagePosition);
  const pos1 = new THREE.Vector3().fromArray(sortedSlices[1].imagePosition);
  zSpacing = pos0.distanceTo(pos1);
  ```
  这个`zSpacing`是物理世界中真实的层间距，不受扫描方式影响。使用它来计算体数据的总物理尺寸和变换矩阵，保证了所有视图的渲染比例都是精确无误的。这一修正极大地提升了代码的健壮性和准确性。
