## 步骤0.3: 理论/API - Three.js 中的数据纹理 (`DataTexture` / `Data3DTexture`)

在 Three.js 或者说 WebGL 中，**纹理 (Texture)** 是将大量数据传递给着色器（尤其是片元着色器）的**最主要、最高效**的方式。

通常我们一提到纹理，想到的都是 `.jpg` 或 `.png` 这样的彩色图片。但纹理的本质远不止于此。你可以把它理解为**一块 GPU 显存上的通用数据缓冲区**，它就是一个可以被着色器程序高速读取的大数组。

### **1. `DataTexture` 和 `Data3DTexture` 的角色**

- **普通 `Texture`**: 主要用于加载标准的图像文件。Three.js 的 `TextureLoader` 会在后台解码图片，然后将像素数据上传到 GPU。这个过程对我们是透明的。

- **`DataTexture` (2D 数据纹理)**: 当我们的数据**不是一张标准的图片**，而是程序在内存中直接生成或解析出来的一大块原始数据时（例如，从 DICOM 文件中解压出的单张切片的像素数据），`DataTexture` 就派上用场了。它允许我们直接用 JavaScript 中的 `TypedArray` (如 `Float32Array`, `Uint8Array` 等) 来创建一张纹理，拥有对数据内容的完全控制。

- **`Data3DTexture` (3D 数据纹理)**: 这是 `DataTexture` 的三维版本，也是我们课程后半段的绝对核心。它允许我们把整个 DICOM 序列的所有切片数据，一次性地构建成一个三维的“数据体”，并上传到 GPU。
  - **前提**: `Data3DTexture` 依赖于 **WebGL2** 的支持。如果用户的浏览器不支持 WebGL2，我们就无法使用它。幸运的是，如今绝大多数现代浏览器都支持 WebGL2。

### **2. 为什么我们需要它们来处理医疗数据？**

1.  **原始数据保真度**: DICOM 中的像素数据（例如 CT 值）是有明确物理意义的数值，范围可能从 -1024 到 3071 或者更高。我们不能像处理普通图片那样，让它被自动压缩或转换成 0-255 的颜色值，那样会丢失全部的原始信息。我们需要将这些原始数值（可能是 `Int16` 或 `Float32`）**原封不动**地送给 GPU。

2.  **GPU 端计算**: 我们的核心目标之一，就是在 GPU 着色器中实时地进行窗宽窗位（WW/WL）计算。为了做到这一点，片元着色器在运行时**必须能访问到原始的 CT 值**。`DataTexture` 正是实现这一点的完美载体。

3.  **三维操作的基础**: 对于 MPR（多平面重建）、Volume Rendering（体渲染）等高级操作，我们需要能够在三维空间中对任意位置进行**采样和插值**。`Data3DTexture` 将整个数据体都放在了 GPU 中，使得着色器可以极其高效地在 3D 空间中进行寻址和采样，这是所有高级 3D 可视化的性能基石。

### **3. 纹理格式 (Format) 与过滤器 (Filter) 的选择策略**

当创建一个 `DataTexture` 时，我们需要告诉 Three.js 我们的数据是什么样的，以及希望 GPU 如何处理它。

- **格式 (Format & Type)**:

  - `format`: 定义了每个像素包含多少个颜色通道。对于灰度的 CT 数据，我们通常使用 `RedFormat`，表示每个像素只有一个红色通道的数据。这最节省显存。如果我们想预先计算颜色，也可以用 `RGBAFormat`。
  - `type`: 定义了每个通道的数据类型，这至关重要。
    - `THREE.UnsignedByteType`: 对应 `Uint8Array`，数值范围 0-255。
    - `THREE.FloatType`: 对应 `Float32Array`，32 位浮点数，精度最高，但最耗显存。
    - `THREE.HalfFloatType`: 16 位浮点数，是精度和性能之间的一个很好的平衡点，也是 WebGL2 的一个重要特性。
  - **策略**: 为了不丢失信息，我们需要选择一个能完全容纳原始 CT 值的 `type`。通常我们会将 DICOM 的 `Int16Array` 数据转换成 `Float32Array` 来创建 `FloatType` 的纹理，以保证最高的保真度。

- **过滤器 (Filter)**:
  - 它定义了当我们的纹理坐标不是精确地落在某个像素中心，而是在几个像素之间时，GPU 应该如何计算出这个点的颜色值。
  - `THREE.NearestFilter`: **最近邻过滤**。它会直接取离采样点最近的那个像素的值。结果是图像会呈现出清晰的、块状的像素感。
  - `THREE.LinearFilter`: **线性过滤**。它会取采样点周围的 4 个像素（2D 纹理）或 8 个像素（3D 纹理）的值，然后根据距离进行加权平均，计算出一个插值。结果是图像看起来更平滑、更模糊。
  - **策略**:
    - 在**显示原始切片**时，为了精确地看到每一个像素的真实值，我们通常会**首选 `NearestFilter`**，避免插值带来的数据“污染”。
    - 在进行**三维重建（如 MPR）或者体渲染**时，为了获得平滑的视觉效果，避免“锯齿感”，我们**必须使用 `LinearFilter`** 来让 GPU 为我们进行硬件加速的三线性插值。

---

### **问答归档**

**问1: `format`和`type`的关系，为什么`Int16Array`要转`Float32Array`，以及为什么纹理坐标会落在像素之间？**

**答:**
这三个问题提得非常好，完全是实践中会遇到的典型困惑。

- **关于 `format` 和 `type`**:

  - `format` 的选择，取决于你往纹理里“塞”什么数据。如果只塞原始CT值（一个强度值），就用 `RedFormat` 最省显存。如果提前在CPU算好了颜色，才用 `RGBAFormat`，但这会丧失GPU的灵活性。
  - `format` 和 `type` 是**正交**关系，共同定义数据布局。`format`决定一个像素有几个分量，`type`决定每个分量的数据类型。

- **关于 `Int16Array` 转 `Float32Array`**:

  - 核心原因是 **WebGL/GPU 的纹理格式支持限制**。
  - GPU 硬件对**浮点数纹理**的线性插值 (`LinearFilter`) 支持是**最通用、最可靠**的。而整数纹理的硬件线性插值在某些设备上可能不支持。
  - 另外，某些整数纹理格式在采样时会被 GPU **自动归一化**（例如，将`[-32768, 32767]`映射到`[-1.0, 1.0]`），这会彻底丢失原始 CT 值，导致窗宽窗位等计算无法进行。
  - 因此，将数据转为 `Float32Array` 并使用 `FloatType` 纹理，是**一劳永逸地解决所有潜在的硬件兼容性和插值问题**的最佳实践，是典型的空间换稳定策略。

- **关于纹理坐标落在像素之间**:
  - 数据存储是离散的，但**渲染采样是连续的**。
  - 当我们将纹理贴到一个比它大的模型上，或者进行旋转、斜切（如MPR）时，渲染平面的采样点几乎**不可能**总是精确地落在体素中心。它们会落在几个体素之间的某个**浮点数坐标**上。
  - 这时就需要**过滤器 (Filter)** 来决策：`NearestFilter` 会取最近的那个体素值，产生锯齿感；`LinearFilter` 则会根据周围的邻居（2D是4个，3D是8个）进行加权平均，硬件加速地计算出一个平滑的插值结果，这对于高质量的重建至关重要。

**问2 (深入追问): `format`和`type`的组合方式，归一化如何丢失数据，以及3D八点插值的具体例子？**

**答:**

- **`format` 和 `type` 的组合**:

  - 您的理解是100%正确的。`format: RedFormat, type: FloatType` 意味着每个像素的数据就是数组中 **1** 个 `Float32` 元素。`format: RGBAFormat, type: FloatType` 意味着每个像素的数据是数组中连续 **4** 个 `Float32` 元素。它们共同定义了如何从一块连续内存中“切分”和“解释”出每个像素。

  我们来举一个具体的内存布局例子，假设我们有一个 Float32Array:
  const data = new Float32Array([100.0, -50.0, 1234.5, 200.0, ...]);
  组合1: format: RedFormat, type: FloatType
  GPU 会这样解读 data 数组：
  第一个 32位浮点数 (100.0) 是第1个像素的值。
  第二个 32位浮点数 (-50.0) 是第2个像素的值。
  第三个 32位浮点数 (1234.5) 是第3个像素的值。
  ...以此类推。
  结论：每个像素的数据，就是数组中 1 个 Float32 类型的元素。
  组合2: format: RGBAFormat, type: FloatType
  GPU 会这样解读 data 数组：
  前4个 32位浮点数 (100.0, -50.0, 1234.5, 200.0) 共同组成了第1个像素的 R, G, B, A 四个分量。
  接下来4个 32位浮点数 是第2个像素的 R, G, B, A 四个分量。
  ...以此类推。
  结论：每个像素的数据，是数组中连续 4 个 Float32 类型的元素。

- **归一化丢失数据的例子**:

  - **场景**: 骨头CT值为 `+1000`，空气为 `-1000`。
  - **错误路线 (归一化)**: GPU将 `+1000` 映射成 `0.03`，`-1000` 映射成 `-0.03`。在着色器中，`+1000` 这个绝对数值信息丢失了，你无法再根据它进行窗宽窗位 `[-160, 240]` 的范围判断。
  - **正确路线 (`FloatType`)**: GPU采样得到的值就是 `1000.0` 和 `-1000.0`，所有原始信息都被保留，可以进行精确的窗宽窗位计算。

- **3D八点插值 (三线性插值) 的例子**:
  - **场景**: 想象一个2x2x2的魔方，由8个体素（小立方体）组成。一个采样点正好落在魔方的正中心 `(0.5, 0.5, 0.5)`。
  - **GPU过程**:
    1.  先在魔方的**底层**4个点 `(z=0)` 中，对 `(0.5, 0.5)` 进行2D线性插值，得到一个值 `V_bottom`。
    2.  再在魔方的**顶层**4个点 `(z=1)` 中，对 `(0.5, 0.5)` 进行2D线性插值，得到一个值 `V_top`。
    3.  最后，在 `V_bottom` 和 `V_top` 之间，根据Z轴位置 `0.5` 进行1D线性插值（即取平均值），得到最终平滑的采样结果。这个过程利用了全部8个邻居的信息。

**问3 (再次深入): 为什么 `Int16Array` 数据会被归一化，而 `Float32Array` 不会？**

**答:**

- **核心答案**: 这取决于所选择的**WebGL纹理内部格式的规范**，而不是输入数据类型本身。
- **两种设计意图**:
  1.  **“颜色”意图 (归一化)**: 大多数整数纹理格式（如`gl.RGBA8`）被设计用来存储颜色。GPU 约定俗成地认为你想把 `[0, 255]` 的整数范围当作 `[0.0, 1.0]` 的颜色强度来用，所以它会自动归一化，这是一种便利。
  2.  **“数据”意图 (非归一化)**: 浮点纹理格式（如`gl.R32F`）被设计用来存储纯粹的数据。其规范就是**所见即所得**，存入 `1000.0`，读取出来就是 `1000.0`，绝不自动修改。
- **Three.js 的角色**: `type: THREE.FloatType` 恰好引导 Three.js 选择了“数据”意图的浮点格式，保证了数据保真。而直接使用整数 `type` 时，则很可能选择了“颜色”意图的归一化格式。因此，`FloatType` 是我们最安全、最明确的选择。
