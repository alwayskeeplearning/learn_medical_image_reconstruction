## 步骤0.4: 实践 - 搭建 Three.js 基础场景

**目标**: 在浏览器中渲染一个彩色的、自旋转的立方体。

### **1. API 先行**

1.  **`THREE.Scene` (场景)**

    - **作用**: 场景是所有 3D 物体的“容器”或“世界”。你可以把它想象成一个虚拟的舞台，我们之后创建的所有物体、相机、灯光都需要被添加到这个场景中，才能被渲染出来。
    - **创建**: `const scene = new THREE.Scene();`

2.  **`THREE.PerspectiveCamera` (透视相机)**

    - **作用**: 它模拟了人眼的观察方式，能产生“近大远小”的透视效果。它决定了我们从哪个角度、以多大的视野去观察场景。
    - **创建**: `new THREE.PerspectiveCamera(fov, aspect, near, far);`
      - `fov` (Field of View): 视场角，也就是相机能看到的视野范围，像人眼的广角或长焦。
      - `aspect`: 宽高比，通常是渲染窗口的 `宽度 / 高度`，用于防止图像变形。
      - `near` 和 `far`: 近裁剪面和远裁剪面。比 `near` 更近或比 `far` 更远的物体将不会被渲染。

3.  **`THREE.WebGLRenderer` (渲染器)**

    - **作用**: 这是 Three.js 的核心，负责将相机观察到的场景内容“绘制”到浏览器的一个 `<canvas>` 元素上。它驱动 GPU 完成我们之前讨论的整个渲染管线流程。
    - **创建**: `const renderer = new THREE.WebGLRenderer({ canvas: yourCanvasElement });`

4.  **`THREE.BoxGeometry` (立方体几何体)**

    - **作用**: 它定义了一个立方体的**形状**，包含了构建一个立方体所需的所有顶点位置、面信息等数据。
    - **创建**: `new THREE.BoxGeometry(width, height, depth);`

5.  **`THREE.MeshNormalMaterial` (法向材质)**

    - **作用**: 它定义了物体的**表面属性**，即“皮肤”。`MeshNormalMaterial` 是一种特殊的、用于调试的材质，它会根据每个面的朝向（法向量）来着色。最终会形成一个五彩斑斓的效果，并且**它不需要任何灯光**，非常适合我们的初始场景。

6.  **`THREE.Mesh` (网格)**

    - **作用**: 这是最终要放入场景的 3D 物体。它是由一个**几何体 `Geometry` (形状)** 和一个**材质 `Material` (皮肤)** 组合而成的。
    - **创建**: `const cube = new THREE.Mesh(geometry, material);`

7.  **渲染循环 (Animation Loop)**
    - **作用**: 3D 场景不是静态的图片。为了让立方体动起来，也为了能用鼠标交互（未来），我们需要创建一个循环，让浏览器在每一帧都重新绘制一次场景。
    - **实现**: 我们会使用浏览器推荐的 `requestAnimationFrame()` 方法来创建这个高效的渲染循环。在每一帧，我们会更新立方体的旋转角度，然后调用 `renderer.render(scene, camera);` 来执行重绘。

### **2. 实践代码**

文件路径: `demos/part0/step0.4/index.ts`

```typescript
import * as THREE from 'three';

const work = () => {
  // 1. 创建场景 (Scene)
  // 场景是所有物体的容器
  const scene = new THREE.Scene();

  // 2. 创建透视相机 (PerspectiveCamera)
  // fov: 视场角, aspect: 宽高比, near: 近裁剪面, far: 远裁剪面
  const camera = new THREE.PerspectiveCamera(75, document.body.clientWidth / document.body.clientHeight, 0.1, 1000);
  // 设置相机位置
  camera.position.z = 5;

  // 3. 创建渲染器 (WebGLRenderer)
  // 获取HTML中的canvas元素
  const canvas = document.getElementById('webgl') as HTMLCanvasElement;
  // 基于canvas元素创建渲染器
  const renderer = new THREE.WebGLRenderer({ canvas });
  // 设置渲染器尺寸为窗口大小
  renderer.setSize(document.body.clientWidth, document.body.clientHeight);

  // 4. 创建几何体 (BoxGeometry)
  // 定义一个1x1x1的立方体
  const geometry = new THREE.BoxGeometry(1, 1, 1);

  // 5. 创建材质 (MeshNormalMaterial)
  // 法向材质会根据面的朝向显示不同颜色，无需灯光
  const material = new THREE.MeshNormalMaterial();

  // 6. 创建网格 (Mesh)
  // 网格由几何体和材质组成
  const cube = new THREE.Mesh(geometry, material);
  // 将立方体添加到场景中
  scene.add(cube);

  // 7. 创建渲染循环 (Animation Loop)
  function animate() {
    // 请求下一帧动画
    requestAnimationFrame(animate);

    // 使立方体旋转
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;

    // 使用渲染器，通过相机将场景渲染出来
    renderer.render(scene, camera);
  }

  // 启动渲染循环
  animate();

  // 8. 监听窗口大小变化，实现响应式
  window.addEventListener('resize', () => {
    // 更新相机宽高比
    camera.aspect = document.body.clientWidth / document.body.clientHeight;
    // 更新相机的投影矩阵
    camera.updateProjectionMatrix();
    // 更新渲染器尺寸
    renderer.setSize(document.body.clientWidth, document.body.clientHeight);
  });

  // 打印当前使用的WebGL版本
  if (renderer.capabilities.isWebGL2) {
    console.log('成功创建 WebGL2 上下文!');
  } else {
    console.log('当前为 WebGL1 上下文。');
  }
};

document.addEventListener('DOMContentLoaded', work);
```

---

### **3. 问答归档**

**问1: `new THREE.WebGLRenderer()` 创建的是 WebGL1 还是 WebGL2 的上下文？**

**答:**
这是一个非常关键的问题。**默认情况下，Three.js 会优先尝试创建 WebGL2 上下文。**

它的内部逻辑是：

1.  首先请求 WebGL2 上下文。
2.  如果用户的浏览器和设备支持，则成功创建并使用 WebGL2。
3.  如果失败，Three.js 会**自动、优雅地降级 (fallback)**，转而请求 WebGL1 上下文。

所以最终版本取决于用户的运行环境。我们可以通过读取 `renderer.capabilities.isWebGL2` 这个布尔值属性来精确地验证当前使用的版本。对于本教程后续依赖 `Data3DTexture` 的高级功能来说，WebGL2 是必需的。

**问2: 为什么旋转的立方体每个面都保持颜色一致，而不是面内的像素颜色有细微不同？**

**答:**
这个问题触及了 GPU **顶点数据插值**的核心概念。

您看到的现象被称为**平坦着色 (Flat Shading)**，其根本原因在于：**对于一个平坦的面，构成它的所有顶点的法向量都是完全相同的。**

1.  **数据源于顶点**: `MeshNormalMaterial` 的颜色来自法向量，而 `BoxGeometry` 为一个平面的所有顶点都定义了同一个法向量（例如顶面所有顶点的法向量都是 `(0, 1, 0)`）。
2.  **GPU进行插值**: GPU 在渲染一个面时，会为面上的每个像素（片元）的属性（如法向量）进行插值。
3.  **插值结果**: 当一个面的所有顶点的法向量都完全相同时，无论怎样插值，面内任何一个像素最终得到的法向量都是同一个值。
4.  **最终着色**: 因此，这个面上的所有像素都使用同一个法向量计算颜色，导致整个面呈现单一、均匀的颜色。

您所预期的那种面内颜色渐变的效果，会在渲染**平滑曲面**（如球体）时出现。因为球面上一个三角形的三个顶点的法向量会有细微差异，插值后就会产生平滑的颜色渐变，这种效果称为**平滑着色 (Smooth Shading)**。
