# 部分5: 步骤 5.2 & 5.3 - MIP 着色器 API 与轴位 Thick Slab 实践

## 1. 步骤 5.2: API - 着色器多次采样循环与参数化

为了在 GLSL（着色器语言）中实现 MIP 算法，我们需要掌握两个核心工具：`for` 循环和 `uniform` 变量。

### 1.1. GLSL 中的 `for` 循环

GLSL 的 `for` 循环语法与 JavaScript 几乎一致，是实现多次重复采样的基础。

```glsl
// 示例代码
float maxValue = -3000.0; // 初始化一个足够小的 CT 值

for (int i = 0; i < 100; i++) {
  // 1. 计算当前采样点的坐标
  vec3 currentSampleCoord = calculate_next_coord(i);
  // 2. 对纹理进行采样
  float sampledValue = texture(u_texture, currentSampleCoord).r;
  // 3. 使用 max() 函数更新最大值
  maxValue = max(maxValue, sampledValue);
}
// 循环结束后，maxValue 即为所求
```

### 1.2. 通过 Uniforms 进行参数化

为了能从外部（TypeScript）动态控制 MIP 的行为，我们需要定义 `uniform` 变量。

- `uniform float u_slabThickness;`: 定义 MIP 的物理厚度，单位是毫米（mm）。这个值由用户通过 UI（如滑块）控制，决定了采样的**几何范围**。
- `uniform int u_samples;`: 定义在上述厚度内进行多少次采样。这个值由开发者设定，是**图像质量**与**程序性能**之间的权衡。

## 2. 步骤 5.3: 实践 - 实现轴位 Thick Slab MIP

本次实践的目标是在现有 MPR 查看器的基础上，为轴位（Axial）视图增加 Thick Slab MIP 功能。

### 2.1. 实践步骤概览

1.  **修改 `index.html`**: 在轴位视图下方，添加一个新的 `<input type="range">` 滑块，用于控制 MIP 厚度。
2.  **修改 `index.ts`**:
    - 获取新添加的滑块 DOM 元素。
    - 为其绑定 `input` 事件监听器。
    - 当滑块值改变时，调用 `viewer.setSlabThickness()` 方法，将新的厚度值传递出去。
3.  **修改 `mpr-viewer.ts`**:
    - 在 `ShaderMaterial` 的 `uniforms` 对象中，添加 `u_slabThickness` 和 `u_samples` 的定义。
    - 创建新的公开方法 `setSlabThickness(thickness: number, ...)`，该方法负责接收 `index.ts` 传来的厚度值（单位：毫米），并直接更新到着色器的 `u_slabThickness.value` 上。
4.  **修改 `fragmentShader.ts`**:
    - 在着色器中声明新的 `uniform float u_slabThickness;` 和 `uniform int u_samples;`。
    - 在 `main()` 函数中，实现 MIP 的核心算法：通过 `for` 循环进行光线步进（Ray Marching），并找出采样路径上的最大值。

### 2.2. 核心算法修正与最终实现

在实践中，我们对 `fragmentShader.ts` 的核心算法进行了探讨和优化，最终采用了更精确、更健壮的实现方式。

```glsl
// ... uniforms 和 in 变量 ...

void main() {
  // ... 计算当前像素在患者坐标系下的中心点 patientPos ...
  // ... 将 patientPos 转换为纹理坐标 sampleCoord ...

  float intensity = 0.0;

  if (u_slabThickness > 0.0) {
    // 确定光线方向（垂直于当前视图平面）
    vec3 rayDir = normalize(cross(uXAxis, uYAxis));

    // 1. 在患者坐标系下计算光线起点和终点（核心思想）
    vec3 startPatient = patientPos - rayDir * u_slabThickness / 2.0;
    vec3 endPatient = patientPos + rayDir * u_slabThickness / 2.0;

    // 2. 将起点和终点从物理世界转换到纹理坐标系
    vec4 startVoxel4 = uPatientToVoxelMatrix * vec4(startPatient, 1.0);
    vec3 startTex = (startVoxel4.xyz / startVoxel4.w + vec3(0.5)) / uTextureSize;

    vec4 endVoxel4 = uPatientToVoxelMatrix * vec4(endPatient, 1.0);
    vec3 endTex = (endVoxel4.xyz / endVoxel4.w + vec3(0.5)) / uTextureSize;

    // 3. 在纹理坐标系下，计算总步进向量和每一步的步长
    vec3 slabVec = endTex - startTex;
    vec3 step = slabVec / float(u_samples - 1);

    float maxVal = -3000.0; // 初始化

    // 4. 从起点开始，按步长进行循环采样
    for (int i = 0; i < u_samples; i++) {
      vec3 coord = startTex + float(i) * step;
      // 边界检查
      if (coord.x >= 0.0 && coord.x <= 1.0 &&
          coord.y >= 0.0 && coord.y <= 1.0 &&
          coord.z >= 0.0 && coord.z <= 1.0)
      {
          maxVal = max(maxVal, texture(uTexture, coord).r);
      }
    }
    intensity = maxVal; // 将找到的最大值作为最终强度
  } else {
    // 如果厚度为0，则执行普通 MPR
    intensity = texture(uTexture, sampleCoord).r;
  }

  // ... 后续窗宽窗位处理 ...
}
```

## 3. Q&A - 深度研讨

### Q1: `u_slabThickness` 和 `u_samples` 这两个 Uniform 变量是否重复？

**A:** 不重复，它们扮演着完全不同且互补的角色，缺一不可。

- **`u_slabThickness` (板层厚度)**: 定义了一个**物理范围**（单位：毫米）。它决定了光线需要穿透多厚的组织，是用户直观控制的**几何概念**。**它回答了“看多远？”**
- **`u_samples` (采样次数)**: 定义了在上述物理范围内的**采样密度**（单位：次）。它决定了计算的**精度**，是开发者设定的**质量参数**。**它回答了“看多仔细？”**

| 参数              | 含义 (What)      | 作用 (Why)        | 控制者 (Who)  | 单位         | 影响 (Impact)                   |
| :---------------- | :--------------- | :---------------- | :------------ | :----------- | :------------------------------ |
| `u_slabThickness` | **采样的总距离** | 定义几何范围      | 用户 (UI)     | 毫米 (mm)    | 图像包含的**解剖深度**          |
| `u_samples`       | **采样点的数量** | 定义计算精度/密度 | 开发者 (代码) | 次 (integer) | 图像**质量** vs **性能** 的权衡 |

### Q2: 请详细解释着色器中计算步长的核心代码。

**A:** 这段代码的目标是精确计算出采样“探针”在三维纹理数据中每一步应该前进的向量。整个过程分为三步，好比一次“精确制导”：

1.  **在患者坐标系下确定起点和终点**: 这是在最直观的物理世界（单位：毫米）中，根据视图中心点、视线方向和总厚度，计算出采样路径的起始和结束的物理位置。这一步保证了基础几何计算的准确性。
    ```glsl
    vec3 startPatient = patientPos - rayDir * u_slabThickness / 2.0;
    vec3 endPatient = patientPos + rayDir * u_slabThickness / 2.0;
    ```
2.  **将物理坐标转换到纹理坐标系**: GPU 操作的是一个从 0.0 到 1.0 的立方体纹理。这一步使用 `uPatientToVoxelMatrix` 矩阵作为“翻译官”，将毫米单位的物理位置，精确换算成 GPU 能理解的 (0-1) 范围内的纹理坐标。
    ```glsl
    vec3 startTex = ...; // 对 startPatient 进行变换
    vec3 endTex = ...;   // 对 endPatient 进行变换
    ```
3.  **在纹理坐标系下计算步长**: 有了纹理空间中的起点 `startTex` 和终点 `endTex`，我们就可以制定“行军计划”。
    - `vec3 slabVec = endTex - startTex;`: 终点减起点，得到一个包含了总行进方向和总行进距离的**总步进向量**。
    - `vec3 step = slabVec / float(u_samples - 1);`: 将总步进向量除以采样间隔数 (`u_samples - 1`)，得到每一步需要前进的**步长向量 `step`**。这个 `step` 最终在 `for` 循环中被累加，引导探针从起点精确走向终点。

这个方法的健壮之处在于，它先在最稳定的物理空间完成几何计算，再一次性、精确地转换到目标坐标系，从而避免了在复杂变换（如斜切）下可能出现的累积误差。
